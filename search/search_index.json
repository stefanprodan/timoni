{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"bundle-distribution/","title":"Bundle Distribution","text":"<p>Bundles and their Runtimes can be distributed as Open Container Initiative (OCI) artifacts.</p>"},{"location":"bundle-distribution/#artifact-format","title":"Artifact format","text":"<p>The OCI artifacts produced with <code>timoni artifact push</code> have the following media types:</p> <ul> <li>Image media type <code>application/vnd.oci.image.manifest.v1+json</code></li> <li>Config media type <code>application/vnd.timoni.config.v1+json</code></li> <li>Layer media type <code>application/vnd.timoni.content.v1.tar+gzip</code></li> </ul> <p>The artifacts are annotated with OCI standard annotations:</p> <ul> <li><code>org.opencontainers.image.source: &lt;GIT URL&gt;</code></li> <li><code>org.opencontainers.image.revision: &lt;GIT COMMIT SHA&gt;</code></li> <li><code>org.opencontainers.image.created: &lt;GIT COMMIT DATE&gt;</code></li> </ul> <p>To enable reproducible builds, Timoni tries to determine the  source, revision and created date from the Git metadata.</p>"},{"location":"bundle-distribution/#publishing-bundles-to-container-registries","title":"Publishing bundles to container registries","text":"<p>Timoni offers a command for publishing bundles, by packaging a local directory as an OCI artifact and pushing the artifact to a container registry.</p> <p>When publishing bundles with timoni artifact push you can:</p> <ul> <li>specify a local directory contain any number of files and subdirectories using the <code>-f</code> flag</li> <li>choose a versioning scheme for your bundles using the <code>--tag</code> flag</li> <li>attach custom metadata such as licenses, Git source and documentation links using the <code>--annotation</code> flag</li> <li>sign the artifact using either with a Cosign static key or Cosign keyless using the <code>--sign</code> flag</li> </ul>"},{"location":"bundle-distribution/#push-and-sign-example","title":"Push and sign example","text":"<p>Login to the container registry:</p> <pre><code>echo $DOCKER_TOKEN | timoni registry login docker.io -u timoni --password-stdin\n</code></pre> <p>Generate a cosign key pair:</p> <pre><code>cosign generate-key-pair\n</code></pre> <p>Export the cosign private key password with:</p> <pre><code>export COSIGN_PASSWORD=&lt;your password&gt;\n</code></pre> <p>Publish and sign an artifact containing bundles and runtimes files:</p> <pre><code>timoni artifact push oci://docker.io/my-org/my-app-bundle \\\n  -f ./my-app/bundles/ \\\n  --sign=cosign \\\n  --cosign-key=cosign.key \\\n  --tag=1.0.0 \\\n  --tag=latest \\\n  --annotation='org.opencontainers.image.licenses=Apache-2.0' \\\n  --annotation='org.opencontainers.image.documentation=https://app.org/docs' \\\n  --annotation='org.opencontainers.image.source=https://github.com/my-org/my-app'\n</code></pre> <p>Add extra tags to the artifact with:</p> <pre><code>timoni artifact tag oci://docker.io/my-org/my-app-bundle:1.0.0 \\\n  --tag=1.0 \\\n  --tag=1\n</code></pre>"},{"location":"bundle-distribution/#using-bundles-from-container-registries","title":"Using bundles from container registries","text":"<p>Timoni offers commands for listing, verifying and extracting bundles and any other files from OCI artifacts stored in container registries.</p>"},{"location":"bundle-distribution/#list-pull-and-apply-example","title":"List, pull and apply example","text":"<p>If the artifact is stored in a private registry, login with:</p> <pre><code>echo $DOCKER_TOKEN | timoni registry login docker.io -u timoni --password-stdin\n</code></pre> <p>List all the artifact's tags and digest with timoni artifact list:</p> <pre><code>timoni artifact list oci://docker.io/my-org/my-app-bundle\n</code></pre> <p>Verify the signature and download a specific artifact tag with timoni artifact pull:</p> <pre><code>timoni artifact pull oci://docker.io/org/app:latest \\\n  --verify cosign \\\n  --cosign-key cosign.pub \\\n  --output .\n</code></pre> <p>If the artifact was signed using Cosign keyless, you can verify it with:</p> <pre><code>timoni artifact pull oci://docker.io/org/app:latest \\\n  --verify cosign \\\n  --certificate-identity-regexp=\"^https://github.com/org/.*$\" \\\n  --certificate-oidc-issuer-regex=\"^https://token.actions.githubusercontent.com.*$\"\n</code></pre> <p>The above command will extract all the files from the remote artifact into the current directory.</p> <p>Deploy the app from a bundle and runtime with timoni bundle apply:</p> <pre><code>timoni bundle apply \\\n  -f app.bundle.cue \\\n  --runtime app.runtime.cue \\\n  --kube-context my-test-cluster\n</code></pre>"},{"location":"bundle-multi-cluster/","title":"Multi-cluster Deployments","text":"<p>Timoni offers a declarative way of managing the delivery of applications across environments. The Timoni Runtime allows defining groups of clusters where apps are being deployed. The Timoni Bundle supports customising the apps configuration based on the target environment (group of clusters) and even for a specific cluster in a group.</p> <pre><code>flowchart LR\n\nA((User)) --&gt; B\nB(Bundle + Runtime) --&gt; C(((Timoni)))\nC --&gt; D(Staging)\nD --&gt; E[1. Region-A]\nD --&gt; F[2. Region-B]\nC--&gt; G(Production)\nG --&gt; H[3. Region-A]\nG --&gt; I[4. Region-B]</code></pre> <p>When applying a Bundle to multiple clusters, Timoni iterates over the clusters in the order defined in the Runtime definition. It connects to each cluster, deploys the app changes, runs health checks, and end-to-end tests before moving to the next cluster.</p>"},{"location":"bundle-multi-cluster/#multi-clusters-definitions","title":"Multi-clusters definitions","text":""},{"location":"bundle-multi-cluster/#runtime-definition","title":"Runtime definition","text":"<p>The following is an example of a Runtime definition containing a list of clusters:</p> <pre><code>runtime: {\n    apiVersion: \"v1alpha1\"\n    name:       \"fleet\"\n    clusters: {\n        \"preview-eu-1\": {\n            group:       \"staging\"\n            kubeContext: \"eks-eu-west-2\"\n        }\n        \"preview-us-1\": {\n            group:       \"staging\"\n            kubeContext: \"eks-us-west-2\"\n        }\n        \"prod-eu-1\": {\n            group:       \"production\"\n            kubeContext: \"eks-eu-west-1\"\n        }\n        \"prod-us-1\": {\n            group:       \"production\"\n            kubeContext: \"eks-us-west-1\"\n        }\n    }\n    values: [\n        {\n            query: \"k8s:v1:Namespace:default\"\n            for: {\n                \"CLUSTER_UID\": \"obj.metadata.uid\"\n            }\n        },\n    ]\n}\n</code></pre> <p>A cluster entry is composed of:</p> <ul> <li>The name of the cluster, used to unique identify a Kubernetes cluster.</li> <li>The group, used to denote the environment a cluster belongs to.</li> <li>The kubeContext, used to select a context from the kubeconfig file.</li> </ul> <p>kubeconfig</p> <p>Note that all clusters defined in the Runtime file must have a corresponding context in the kubeconfig file. By default, Timoni looks for a file named <code>config</code> in the <code>$HOME/.kube</code> directory. You can specify other kubeconfig file by setting the <code>KUBECONFIG</code> environment variable or by setting the <code>--kubeconfig</code> flag.</p> <p>The <code>values</code> list can be used to query each cluster to extract values needed to configure Ingress, TLS, auth, etc, during the app deployment. For more information on how to query a cluster, please see the runtime values doc.</p>"},{"location":"bundle-multi-cluster/#bundle-definition","title":"Bundle definition","text":"<p>The following is an example of a Bundle definition that uses the cluster attributes to set the number of replicas to different values for staging and production:</p> <pre><code>bundle: {\n    _cluster: {\n        name:  string @timoni(runtime:string:TIMONI_CLUSTER_NAME)\n        group: string @timoni(runtime:string:TIMONI_CLUSTER_GROUP)\n        uid:   string @timoni(runtime:string:CLUSTER_UID)\n    }\n\n    apiVersion: \"v1alpha1\"\n    name:       \"apps\"\n    instances: {\n        podinfo: {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/podinfo\"\n            namespace: \"apps\"\n            values: {\n                ui: message: \"Hosted by \\(_cluster.name) id \\(_cluster.uid)\"\n                if _cluster.group == \"staging\" {\n                    replicas: 1\n                }\n                if _cluster.group == \"production\" {\n                    replicas: 2\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>The cluster name and group, are mapped to fields in a Bundle using the following attributes:</p> <ul> <li><code>@timoni(runtime:string:TIMONI_CLUSTER_NAME)</code></li> <li><code>@timoni(runtime:string:TIMONI_CLUSTER_GROUP)</code></li> </ul>"},{"location":"bundle-multi-cluster/#multi-cluster-operations","title":"Multi-cluster operations","text":""},{"location":"bundle-multi-cluster/#validation","title":"Validation","text":"<p>Build the Runtime definition to verify the connectivity to each cluster:</p> commandoutput <pre><code>timoni runtime build -f runtime.cue\n</code></pre> <pre><code>r:fleet &gt; c:preview-eu-1 &gt; CLUSTER_UID: bc83fc97-3cb9-42ca-ae38-cc09501e01e3\nr:fleet &gt; c:prod-eu-1 &gt; CLUSTER_UID: 61fad037-bc8a-420e-a7b2-1d72fdc17e61\n</code></pre> <p>Print the Bundle variants to verify the final values used for each cluster:</p> commandoutput <pre><code>timoni bundle vet --print-value -f bundle.cue -r runtime.cue\n</code></pre> <pre><code>\"preview-eu-1\": bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"apps\"\n    instances: {\n        podinfo: {\n            module: {\n                url:     \"oci://ghcr.io/stefanprodan/modules/podinfo\"\n                version: *\"latest\" | string\n            }\n            namespace: \"apps\"\n            values: {\n                test: {\n                    enabled: true\n                }\n                replicas: 1\n                ui: {\n                    message: \"Hosted by preview-eu-1 id bc83fc97-3cb9-42ca-ae38-cc09501e01e3\"\n                }\n            }\n        }\n    }\n}\n\"prod-eu-1\": bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"apps\"\n    instances: {\n        podinfo: {\n            module: {\n                url:     \"oci://ghcr.io/stefanprodan/modules/podinfo\"\n                version: *\"latest\" | string\n            }\n            namespace: \"apps\"\n            values: {\n                test: {\n                    enabled: true\n                }\n                replicas: 2\n                ui: {\n                    message: \"Hosted by prod-eu-1 id 61fad037-bc8a-420e-a7b2-1d72fdc17e61\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Perform a dry-run apply of the Bundle to review the changes across clusters:</p> commandoutput <pre><code>timoni bundle apply --dry-run -f bundle.cue -r runtime.cue\n</code></pre> <pre><code>b:apps &gt; c:preview-eu-1 &gt; applying 1 instance(s) on staging (server dry run)\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; applying module timoni.sh/podinfo version 6.5.4\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; Namespace/apps created (server dry run)\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; ServiceAccount/apps/podinfo created (server dry run)\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; Service/apps/podinfo created (server dry run)\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; Deployment/apps/podinfo created (server dry run)\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; Job/apps/podinfo-test created (server dry run)\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; applied successfully (server dry run)\nb:apps &gt; c:preview-eu-1 &gt; applied successfully (server dry run)\nb:apps &gt; c:prod-eu-1 &gt; applying 1 instance(s) on production (server dry run)\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; applying module timoni.sh/podinfo version 6.5.4\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; Namespace/apps created (server dry run)\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; ServiceAccount/apps/podinfo created (server dry run)\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; Service/apps/podinfo created (server dry run)\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; Deployment/apps/podinfo created (server dry run)\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; Job/apps/podinfo-test created (server dry run)\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; applied successfully (server dry run)\nb:apps &gt; c:prod-eu-1 &gt; applied successfully (server dry run)\n</code></pre>"},{"location":"bundle-multi-cluster/#install-and-upgrade","title":"Install and Upgrade","text":"<p>To install or upgrade the instances defined in the Bundle to all clusters:</p> commandoutput <pre><code>timoni bundle apply -f bundle.cue -r runtime.cue\n</code></pre> <pre><code>b:apps &gt; c:preview-eu-1 &gt; applying 1 instance(s) on staging\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; applying module timoni.sh/podinfo version 6.5.4\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; installing podinfo in namespace apps\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; Namespace/apps created\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; applying app\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; ServiceAccount/apps/podinfo created\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; Service/apps/podinfo created\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; Deployment/apps/podinfo created\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; app resources ready\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; applying test\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; Job/apps/podinfo-test created\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; test resources ready\nb:apps &gt; c:preview-eu-1 &gt; applied successfully in 22s\nb:apps &gt; c:prod-eu-1 &gt; applying 1 instance(s) on production\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; applying module timoni.sh/podinfo version 6.5.4\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; installing podinfo in namespace apps\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; Namespace/apps created\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; applying app\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; ServiceAccount/apps/podinfo created\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; Service/apps/podinfo created\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; Deployment/apps/podinfo created\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; app resources ready\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; applying test\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; Job/apps/podinfo-test created\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; test resources ready\nb:apps &gt; c:prod-eu-1 &gt; applied successfully in 44s\n</code></pre> <p>Note that Timoni deploys the app instances to all the clusters, in the order defined in the Runtime. If the apply fails on a staging cluster, Timoni will stop the execution and not continue with production.</p> <p>After editing a bundle file, to review the changes that will be made on all clusters:</p> <pre><code>timoni bundle apply -f bundle.cue -r runtime.cue --dry-run --diff\n</code></pre>"},{"location":"bundle-multi-cluster/#status","title":"Status","text":"<p>To list the current status of the deployed apps on all clusters:</p> commandoutput <pre><code>timoni bundle status -f bundle.cue -r runtime.cue\n</code></pre> <pre><code>b:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; last applied 2023-11-25T12:50:02Z\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; module oci://ghcr.io/stefanprodan/modules/podinfo:6.5.4\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; digest sha256:1dba385f9d56f9a79e5b87344bbec1502bd11f056df51834e18d3e054de39365\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; container image ghcr.io/curl/curl-container/curl-multi:master\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; container image ghcr.io/stefanprodan/podinfo:6.5.4\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; ServiceAccount/apps/podinfo Current - Resource is current\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; Service/apps/podinfo Current - Service is ready\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; Deployment/apps/podinfo Current - Deployment is available. Replicas: 1\nb:apps &gt; c:preview-eu-1 &gt; i:podinfo &gt; Job/apps/podinfo-test Current - Job Completed. succeeded: 1/1\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; last applied 2023-11-25T12:50:24Z\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; module oci://ghcr.io/stefanprodan/modules/podinfo:6.5.4\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; digest sha256:1dba385f9d56f9a79e5b87344bbec1502bd11f056df51834e18d3e054de39365\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; container image ghcr.io/curl/curl-container/curl-multi:master\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; container image ghcr.io/stefanprodan/podinfo:6.5.4\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; ServiceAccount/apps/podinfo Current - Resource is current\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; Service/apps/podinfo Current - Service is ready\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; Deployment/apps/podinfo Current - Deployment is available. Replicas: 2\nb:apps &gt; c:prod-eu-1 &gt; i:podinfo &gt; Job/apps/podinfo-test Current - Job Completed. succeeded: 1/1\n</code></pre> <p>Or using the bundle name:</p> <pre><code>timoni bundle status my-bundle -r runtime.cue\n</code></pre>"},{"location":"bundle-multi-cluster/#uninstall","title":"Uninstall","text":"<p>To delete all deployed apps on all clusters:</p> commandoutput <pre><code>timoni bundle delete -f bundle.cue -r runtime.cue\n</code></pre> <pre><code>b:apps &gt; c:preview-eu-1 &gt; deleting instance podinfo in namespace apps\nb:apps &gt; c:preview-eu-1 &gt; Job/apps/podinfo-test deleted\nb:apps &gt; c:preview-eu-1 &gt; Deployment/apps/podinfo deleted\nb:apps &gt; c:preview-eu-1 &gt; Service/apps/podinfo deleted\nb:apps &gt; c:preview-eu-1 &gt; ServiceAccount/apps/podinfo deleted\nb:apps &gt; c:preview-eu-1 &gt; all resources have been deleted\nb:apps &gt; c:prod-eu-1 &gt; deleting instance podinfo in namespace apps\nb:apps &gt; c:prod-eu-1 &gt; Job/apps/podinfo-test deleted\nb:apps &gt; c:prod-eu-1 &gt; Deployment/apps/podinfo deleted\nb:apps &gt; c:prod-eu-1 &gt; Service/apps/podinfo deleted\nb:apps &gt; c:prod-eu-1 &gt; ServiceAccount/apps/podinfo deleted\nb:apps &gt; c:prod-eu-1 &gt; all resources have been deleted\n</code></pre> <p>Or using the bundle name:</p> <pre><code>timoni bundle delete my-bundle -r runtime.cue\n</code></pre>"},{"location":"bundle-multi-cluster/#cluster-filtering","title":"Cluster filtering","text":"<p>To perform an apply only on a group of clusters:</p> <pre><code>timoni bundle apply -f bundle.cue -r runtime.cue --runtime-group staging\n</code></pre> <p>To perform an apply only on a cluster:</p> <pre><code>timoni bundle apply -f bundle.cue -r runtime.cue --runtime-cluster prod-eu-1\n</code></pre> <p>Note that all <code>timoni bundle</code> commands support filtering by cluster name and group.</p>"},{"location":"bundle-runtime/","title":"Bundle Runtime","text":"<p>While Timoni Bundles offer a way to specify the config values in declarative manner, not all the configuration values of an application are known ahead of time. Some values may be available at runtime, in the Kubernetes clusters where the Bundle is applied.</p> <p>For example, the API token for some backend service that your app consumes is stored in a Kubernetes Secret in-cluster. When installing the application with Timoni, you may want to fetch the token from the Kubernetes Secret and use it as a config value.</p> <p>Timoni Runtime API offers a way to define values which are fetched from the Kubernetes API and mapped to fields inside a Bundle.</p>"},{"location":"bundle-runtime/#example","title":"Example","text":"<p>The following is an example of a Runtime definition that extracts values from the cluster.</p> <pre><code>runtime: {\n    apiVersion: \"v1alpha1\"\n    name:       \"production\"\n    clusters: {\n        // using the cluster set in kubeconfig current context\n    }\n    values: [\n        {\n            query: \"k8s:v1:ConfigMap:infra:aws-info\"\n            for: {\n                \"ACCOUNT_ID\": \"obj.data.account_id\"\n                \"REGION\":     \"obj.data.region\"\n            }\n        },\n        {\n            query: \"k8s:v1:Secret:infra:redis-auth\"\n            for: {\n                \"REDIS_PASS\": \"obj.data.password\"\n                \"REDIS_CA\":   \"obj.data.\\\"ca.crt\\\"\"\n            }\n        },\n    ]\n}\n</code></pre> <p>The values from the Runtime, can be mapped to fields in a Bundle using <code>@timoni()</code> attributes.</p> <pre><code>bundle: {\n    _id:   string @timoni(runtime:string:ACCOUNT_ID)\n    _reg:  string @timoni(runtime:string:REGION)\n    _pass: string @timoni(runtime:string:REDIS_PASS)\n\n    apiVersion: \"v1alpha1\"\n    name:       \"podinfo\"\n    instances: {\n        podinfo: {\n            module: url: \"oci://\\(_id).dkr.ecr.\\(_reg).amazonaws.com/modules/podinfo\"\n            namespace: \"podinfo\"\n            values: caching: {\n                enabled:  true\n                redisURL: \"tcp://:\\(_pass)@redis.infra:6379\"\n            }\n        }\n    }\n}\n</code></pre> <p>Assuming the ConfigMaps and Secrets are in the cluster, and the Runtime file is <code>runtime.cue</code> and the Bundle file is <code>bundle.cue</code>.</p> <p>Build the runtime to see which values are present on the cluster:</p> commandoutput <pre><code>timoni runtime build -f runtime.cue\n</code></pre> <pre><code>ACCOUNT_ID: 1234567890\nREGION: us-west-2\nREDIS_PASS: password\nREDIS_CA:\n  -----BEGIN CERTIFICATE-----\n  MIIC/jCCAeagAwIBAgIBADANBgkqhkiG9w0BAQsFADAVMRMwEQYDVQQDEwprdWJl\n  cm5ldGVzMB4XDTIzMDgxMDE1MTA1MFoXDTMzMDgwNzE1MTA1MFowFTETMBEGA1UE\n  AxMKa3ViZXJuZXRlczCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJgA\n  mOniTayGyXG51eYeb1oJGCszRlZv4ci2kzLC0H4YCph6TXDEawrsvyuzGe7fwp4t\n  Jq2fQiJgKbibOjHcOwhYqp1lJDu37p6WsLvx/RxbkHoVX8X2n7n1BVS5MbQ81on9\n  BdXkff71g8n3HmJo8ZN1abEW434tHFwjjGMDzFoqxTnNM+qMKegxAtTPVbjV4X+5\n  4/95L7T0XNd97XnunSUAEJRroMTRuaBAcYz81N0ix3Mc0T+G16aV127R0ZFkPlS8\n  bzjA1NGgbiveX7i7n9mNG4Gy7iElP0iidtdrA6loxWYLW1jmEH5/pWQnki7s3OrK\n  /94xrQ2MaDpXUzcoc0cCAwEAAaNZMFcwDgYDVR0PAQH/BAQDAgKkMA8GA1UdEwEB\n  /wQFMAMBAf8wHQYDVR0OBBYEFJ7f9QzKWA/BQJSRinKne4FZNzScMBUGA1UdEQQO\n  MAyCCmt1YmVybmV0ZXMwDQYJKoZIhvcNAQELBQADggEBAAhGgYFB90Rkexgh56q8\n  n8uC4XQF6OTJJf/4A9VXNbiZhG+PUYkMUyqeOSOq+IztJVOffuG9ZutYQtJYCX7g\n  TUQmZxeKAw1MAMEWAELmNVdbG6Y6YZ14v8SI+TADqeqcIkmDEkACygfeHKdEFOfV\n  LoRAc3Zn32byP5M6EVjTXWvb+UbVt7umoBOCbMo3BEF71TEDI5Oww6y3YxDM9/Y7\n  MCTu+0XHZNGDgprmci6fzLv8PV0C6eiuUrrBM237WOfk4BYL6pmCDcCWo6aP2cH7\n  Y5zcVBxKUs/h5bZfLJFuwXJC5zWudNLOAtNtFhctMwDoNaKYq720g/GmEroq4wgA\n  tBI=\n  -----END CERTIFICATE-----\n</code></pre> <p>Apply the Bundle using the values from the Runtime:</p> commandoutput <pre><code>timoni bundle apply -f bundle.cue --runtime runtime.cue\n</code></pre> <pre><code>applying instance podinfo\npulling oci://1234567890.dkr.ecr.us-west-2.amazonaws.com/modules/podinfo\nusing module timoni.sh/podinfo version 6.3.5\ninstalling podinfo in namespace podinfo\nServiceAccount/podinfo/podinfo created\nService/podinfo/podinfo created\nDeployment/podinfo/podinfo created\nwaiting for 3 resource(s) to become ready...\nresources are ready\n</code></pre>"},{"location":"bundle-runtime/#writing-a-runtime-spec","title":"Writing a Runtime spec","text":"<p>A Runtime file must contain a definition that matches the following schema:</p> <pre><code>#Runtime: {\n    apiVersion: string\n    name:       string\n\n    clusters?: [string]: {\n        group!:       string\n        kubeContext!: string\n    }\n\n    values?: [...#RuntimeValue]\n}\n\n#RuntimeValue: {\n    query: string\n    for: {[string]: string}\n    optional: *false | bool\n}\n</code></pre>"},{"location":"bundle-runtime/#api-version","title":"API version","text":"<p>The <code>apiVersion</code> is a required field that specifies the version of the Runtime schema.</p> <p>Currently, the only supported value is <code>v1alpha1</code>.</p>"},{"location":"bundle-runtime/#name","title":"Name","text":"<p>The <code>name</code> is a required field used to identify the Runtime.</p>"},{"location":"bundle-runtime/#clusters","title":"Clusters","text":"<p>The <code>clusters</code> field is for defining the target clusters and environments (group of clusters) where a Bundle is applied.</p> <p>A cluster entry must specify the <code>group</code> and <code>kubeContext</code> fields. The <code>kubeContext</code> value must match a context name from the <code>.kube/config</code> file.</p> <p>Default cluster</p> <p>When no clusters are defined in the Runtime, Timoni will use the current context from the kubeconfig, unless the context is specifed using the <code>--kube-context</code> flag.</p> <p>Example:</p> <pre><code>runtime: {\n    apiVersion: \"v1alpha1\"\n    name:       \"fleet\"\n    clusters: {\n        \"preview-us-1\": {\n            group:       \"staging\"\n            kubeContext: \"eks-us-west-2\"\n        }\n        \"prod-us-1\": {\n            group:       \"production\"\n            kubeContext: \"eks-us-west-1\"\n        }\n        \"prod-eu-1\": {\n            group:       \"production\"\n            kubeContext: \"eks-eu-west-1\"\n        }\n    }\n}\n</code></pre> <p>The clusters name and group, can be mapped to fields in a Bundle using <code>@timoni()</code> attributes.</p> <pre><code>bundle: {\n    _cluster: string @timoni(runtime:string:TIMONI_CLUSTER_NAME)\n    _env:     string @timoni(runtime:string:TIMONI_CLUSTER_GROUP)\n\n    apiVersion: \"v1alpha1\"\n    name:       \"apps\"\n    instances: {\n        app: {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/podinfo\"\n            namespace: \"apps\"\n            values: {\n                ui: message: \"Hosted by \\(_cluster)\"\n                if _env == \"staging\" {\n                    replicas: 1\n                }\n                if _env == \"production\" {\n                    replicas: 2\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>When applying the above Bundle, Timoni will deploy the app instances to all the clusters, in the order defined in the Runtime. If the apply fails on a staging cluster, Timoni will stop the execution and not continue with production.</p> <p>For more details please see the multi-cluster deployments guide.</p>"},{"location":"bundle-runtime/#values","title":"Values","text":"<p>The <code>values</code> array is for specifying the list of Kubernetes resources and the fields to be extracted.</p>"},{"location":"bundle-runtime/#query","title":"Query","text":"<p>The <code>values.query</code> is a required field that specifies the Kubernetes resource.</p> <p>The <code>query</code> field must be in the format <code>k8s:&lt;apiVersion&gt;:&lt;kind&gt;:&lt;namespace&gt;:&lt;name&gt;</code>.</p> <p>Example:</p> <pre><code>runtime: {\n    apiVersion: \"v1alpha1\"\n    name:       \"production\"\n    values: [\n        {\n            query: \"k8s:v1:Secret:infra:redis-auth\"\n            for: {\n                \"REDIS_PASS\": \"obj.data.password\"\n            }\n        },\n    ]\n}\n</code></pre> <p>If the Kubernetes resource is global, the <code>query</code> format is <code>k8s:&lt;apiVersion&gt;:&lt;kind&gt;:&lt;name&gt;</code>.</p> <p>Example:</p> <pre><code>runtime: {\n    apiVersion: \"v1alpha1\"\n    name:       \"production\"\n    values: [\n        {\n            query: \"k8s:cert-manager.io/v1:ClusterIssuer:letsencrypt\"\n            for: {\n                \"ISSUER_EMAIL\": \"obj.spec.acme.email\"\n            }\n        },\n    ]\n}\n</code></pre>"},{"location":"bundle-runtime/#for","title":"For","text":"<p>The <code>values.for</code> is a required map that specifies which fields to be extracted from the Kubernetes resource.</p> <p>The <code>for</code> map must contain pairs of name and CUE expression.</p> <p>Example:</p> <pre><code>runtime: {\n    apiVersion: \"v1alpha1\"\n    name:       \"production\"\n    values: [\n        {\n            query: \"k8s:source.toolkit.fluxcd.io/v1:GitRepository:flux-system:cluster\"\n            for: {\n                \"GIT_REVISION\": \"obj.status.artifact.revision\"\n                \"GIT_STATUS\":   \"[for c in obj.status.conditions if c.type == \\\"Ready\\\" {c.status}][0]\"\n            }\n        },\n    ]\n}\n</code></pre> <p>The CUE expression must result in a concrete value of type <code>string</code>, <code>number</code> or <code>bool</code>.</p>"},{"location":"bundle-runtime/#optional","title":"Optional","text":"<p>The <code>optional</code> field can be set to <code>true</code> and Timoni will skip not found Kubernetes resources instead of throwing an error.</p>"},{"location":"bundle-runtime/#using-values-from-kubernetes-api","title":"Using values from Kubernetes API","text":"<p>The values defined in a Runtime can be referred in Bundles using CUE attributes.</p> <p>The <code>@timoni(runtime:[string|number|bool]:[VAR_NAME])</code> CUE attribute can be placed next to a field to set its value from the runtime.</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"app\"\n    instances: {\n        app: {\n            module: url: \"oci://localhost:5000/modules/app\"\n            namespace: \"apps\"\n            values: {\n                host:    string @timoni(runtime:string:HOST)\n                enabled: bool   @timoni(runtime:bool:ENABLED)\n                score:   int    @timoni(runtime:number:SCORE)\n            }\n        }\n    }\n}\n</code></pre> <p>If a runtime value is optional, you can provide defaults which will be used only if the runtime doesn't contain the referenced value:</p> <pre><code>values: {\n    host:    \"example.com\" @timoni(runtime:string:HOST)\n    enabled: true          @timoni(runtime:bool:ENABLED)\n    score:   1             @timoni(runtime:number:SCORE)\n}\n</code></pre> <p>To load the runtime values at apply time, use the <code>--runtime</code> flag:</p> <pre><code>timoni bundle apply -f bundle.cue --runtime runtime.cue\n</code></pre> <p>At apply time, Timoni injects the fields values from the runtime, if a specified runtime var is not found and if a default is not provided, the apply with fail with an <code>incomplete value</code> error.</p>"},{"location":"bundle-runtime/#using-values-from-environment-variables","title":"Using values from environment variables","text":"<p>To use values from environment variables, the environment must contain variables which match the CUE attributes.</p> <p>Example:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"app\"\n    instances: {\n        app: {\n            module: url: \"oci://localhost:5000/modules/app\"\n            namespace: \"apps\"\n            values: {\n                sshKey:  string @timoni(runtime:string:SSH_KEY)\n                isAdmin: false  @timoni(runtime:bool:IS_ADMIN)\n            }\n        }\n    }\n}\n</code></pre> <p>Export the env vars and run the <code>timoni bundle apply --runtime-from-env</code> command.</p> <pre><code>EXPORT SSH_KEY=$(cat .ssh/id_ecdsa.pub)\nEXPORT IS_ADMIN=\"true\"\n\ntimoni bundle apply -f bundle.cue --runtime-from-env\n</code></pre> <p>Mixing values from the Runtime and Environment</p> <p>When using <code>timoni bundle apply --runtime runtime.cue --runtime-from-env</code>, the values coming from the Runtime take precedence over the Environment.</p>"},{"location":"bundle-secrets/","title":"Bundle Secrets Injection","text":"<p>Ways of injecting secrets when deploying applications with Timoni Bundles:</p> <ul> <li>Using runtime attributes <code>@timoni(runtime:string:SECRET-NAME)</code>.</li> <li>Using SOPS encrypted YAML or JSON files.</li> </ul>"},{"location":"bundle-secrets/#runtime-secrets","title":"Runtime Secrets","text":"<p>To showcase how secrets injections works, we'll assume we are deploying an application that connects to an S3-compatible API and needs two secrets: <code>ACCESS_KEY</code> and <code>SECRET_KEY</code>.</p>"},{"location":"bundle-secrets/#injecting-secrets-from-ci-secret-store","title":"Injecting secrets from CI secret store","text":"<p>When using a CI runner to deploy apps with Timoni, we can pass secrets from the runner's secret store to Timoni's Bundle.</p> <p>Example of a Bundle that contains runtime attributes:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"my-app\"\n    instances: {\n        \"my-app-storage\": {\n            module: url: \"oci://my-registry/timoni/modules/my-app-storage\"\n            namespace: \"my-app\"\n            values: {\n                endpoint:  \"https://my-acc.r2.cloudflarestorage.com\"\n                accessKey: string @timoni(runtime:string:ACCESS_KEY)\n                secretKey: string @timoni(runtime:string:SECRET_KEY)\n            }\n        }\n    }\n}\n</code></pre> <p>In a GitHub workflow, we can map secrets from GitHub secrets to env vars, that Timoni will use at apply-time:</p> <pre><code>export ACCESS_KEY=${{ secrets.ACCESS_KEY }}\nexport SECRET_KEY=${{ secrets.SECRET_KEY }}\n\ntimoni bundle apply -f bundle.cue --runtime-from-env\n</code></pre>"},{"location":"bundle-secrets/#injecting-secrets-from-kubernetes","title":"Injecting secrets from Kubernetes","text":"<p>The same secrets from the above example, can be injected from a Kubernetes Secret, assuming we're using some external-secret controller that syncs secrets from a Vault in etcd.</p> <p>Example of a Timoni Bundle Runtime that fetches the secrets from the cluster:</p> <pre><code>runtime: {\n    apiVersion: \"v1alpha1\"\n    name:       \"production\"\n    values: [\n        {\n            query: \"k8s:v1:Secret:my-namespace:my-secret-name\"\n            for: {\n                \"ACCESS_KEY\": \"obj.data.r2_access_key\"\n                \"SECRET_KEY\": \"obj.data.r2_secret_key\"\n            }\n        },\n    ]\n}\n</code></pre> <p>At apply-time we pass the runtime definition and Timoni will read the secrets from the Kubernetes cluster and use them when applying the bundle:</p> <pre><code>timoni bundle apply -f bundle.cue --runtime runtime.cue\n</code></pre>"},{"location":"bundle-secrets/#secrets-interpolation","title":"Secrets interpolation","text":"<p>When the secrets stored in external system do not map to a value key in the Bundle, we can use CUE's string interpolation to compose the desired value.</p> <p>Assuming an application config expects a Redis URL, but the secret store contains <code>REDIS_HOST</code> and <code>REDIS_PASS</code>.</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"podinfo\"\n    _secrets: {\n        host:     string @timoni(runtime:string:REDIS_HOST)\n        password: string @timoni(runtime:string:REDIS_PASS)\n    }\n    instances: {\n        \"podinfo-backend\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/podinfo\"\n            namespace: \"podinfo\"\n            values: caching: {\n                enabled:  true\n                redisURL: \"tcp://:\\(_secrets.password)@\\(_secrets.host):6379\"\n            }\n        }\n    }\n}\n</code></pre> <p>In the above example, we define a CUE hidden field <code>_secrets</code>, where we set the runtime secrets mappings. Then in the instance values, we use string interpolation to set the <code>redisURL</code> containing the secrets.</p> <p>Using the build command, we can see the URL value set in the podinfo container args:</p> <pre><code>$ export REDIS_HOST=redis.svc\n$ export REDIS_PASS=testpass\n$ timoni bundle build -f bundle.cue --runtime-from-env | grep redis\n        - --cache-server=tcp://:testpass@redis.svc:6379\n</code></pre>"},{"location":"bundle-secrets/#sops-secrets","title":"SOPS secrets","text":"<p>When using SOPS, we can decrypt the secrets and inject those values to env vars, then use <code>--runtime-from-env</code>.</p> <p>Another option is to extract the secret values of a Timoni Bundle to a YAML or JSON file, that we encrypt/decrypt with SOPS.</p>"},{"location":"bundle-secrets/#injecting-secrets-from-sops","title":"Injecting secrets from SOPS","text":"<p>Main bundle file <code>bundle.main.cue</code>:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"my-app\"\n    instances: {\n        \"my-app-storage\": {\n            module: url: \"oci://my-registry/timoni/modules/my-app-storage\"\n            namespace: \"my-app\"\n            values: {\n                endpoint: \"https://my-acc.r2.cloudflarestorage.com\"\n                // The secrets are omitted here!\n            }\n        }\n    }\n}\n</code></pre> <p>Bundle partial in YAML format <code>bundle.secret.yaml</code>:</p> <pre><code>bundle:\n  instances:\n    my-app-storage:\n      values:\n        accessKey: ENC[AES256_GCM,data:..]\n        secretKey: ENC[AES256_GCM,data:..]\n</code></pre> <p>Assuming the <code>bundle.secret.yaml</code> file is kept encrypted with SOPS, at apply-time we can run the SOPS decryption, and pass the plain YAML to Timoni's apply command like so:</p> <pre><code>sops exec-file --filename secrets.yml bundle.secret.yaml 'timoni bundle apply -f bundle.main.cue -f {}'\n</code></pre>"},{"location":"bundle/","title":"Bundle","text":"<p>Timoni bundles offer a declarative way of managing the lifecycle of applications and their infra dependencies.</p> <p>A Timoni bundle is a CUE file for defining a group of instances together with their values and module references.</p>"},{"location":"bundle/#example","title":"Example","text":"<p>The following is an example of a Bundle that defines a Redis master-replica cluster and a podinfo instance connected to the Redis instance.</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"podinfo\"\n    instances: {\n        redis: {\n            module: {\n                url:     \"oci://ghcr.io/stefanprodan/modules/redis\"\n                version: \"7.2.4\"\n            }\n            namespace: \"podinfo\"\n            values: maxmemory: 256\n        }\n        podinfo: {\n            module: url:     \"oci://ghcr.io/stefanprodan/modules/podinfo\"\n            module: version: \"6.5.4\"\n            namespace: \"podinfo\"\n            values: caching: {\n                enabled:  true\n                redisURL: \"tcp://redis:6379\"\n            }\n        }\n    }\n}\n</code></pre> <p>For the above example, Timoni performs the following actions at apply time:</p> <ul> <li>Validates that the Bundle definition is in conformance with the API version specified by <code>apiVersion</code>.</li> <li>For each instance, it fetches the module version from the registry using the <code>module.url</code>   as the artifact repository address and the <code>module.version</code> as the artifact tag.</li> <li>Creates the Kubernetes namespaces if they don't exist.</li> <li>For each instance, it builds, validates and creates the Kubernetes resources using the specified <code>values</code>.</li> <li>The list of managed resources along with the module reference and values are stored in the cluster in a   Kubernetes Secret, in the same namespace with the instance.</li> <li>If an instance already exists, Timoni performs a server-side apply dry-run to detect changes and   applies only the resources with divergent state.</li> <li>If previously applied resources are missing from the current revision, these   resources are deleted from the cluster.</li> <li>Waits for each instance's resources to become ready.</li> </ul> <p>You can run this example by saving the Bundle into <code>podinfo.bundle.cue</code>.</p> <p>Apply the Bundle on the cluster:</p> commandoutput <pre><code>timoni bundle apply -f podinfo.bundle.cue\n</code></pre> <pre><code>applying instance redis\npulling oci://ghcr.io/stefanprodan/modules/redis:7.2.4\nusing module timoni.sh/redis version 7.2.4\ninstalling redis in namespace podinfo\nNamespace/podinfo created\napplying master\nServiceAccount/podinfo/redis created\nConfigMap/podinfo/redis created\nService/podinfo/redis created\nDeployment/podinfo/redis-master created\nPersistentVolumeClaim/podinfo/redis-master created\nwaiting for 5 resource(s) to become ready...\nresources are ready\napplying replica\nService/podinfo/redis-readonly created\nDeployment/podinfo/redis-replica created\nwaiting for 2 resource(s) to become ready...\nresources are ready\napplying instance podinfo\npulling oci://ghcr.io/stefanprodan/modules/podinfo:6.5.4\nusing module timoni.sh/podinfo version 6.5.4\ninstalling podinfo in namespace podinfo\nServiceAccount/podinfo/podinfo created\nService/podinfo/podinfo created\nDeployment/podinfo/podinfo created\nwaiting for 3 resource(s) to become ready...\nresources are ready\n</code></pre> <p>Build the Bundle and print the resulting Kubernetes resources for all the Bundle's instances:</p> commandoutput <pre><code>timoni bundle build -f podinfo.bundle.cue\n</code></pre> <pre><code>---\n# Instance: redis\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\nlabels:\n  app.kubernetes.io/part-of: redis\n  app.kubernetes.io/version: 7.2.4\nname: redis\nnamespace: podinfo\n---\n# Redis deployments omitted for brevity\n---\n# Instance: podinfo\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\nlabels:\n  app.kubernetes.io/name: podinfo\n  app.kubernetes.io/version: 6.5.4\nname: podinfo\nnamespace: podinfo\n---\n# Podinfo deployment omitted for brevity\n</code></pre> <p>List the managed resources from a bundle and their rollout status:</p> commandoutput <pre><code>timoni bundle status -f podinfo.bundle.cue\n</code></pre> <pre><code>last applied 2024-03-03T20:21:19Z\nmodule oci://ghcr.io/stefanprodan/modules/redis:7.2.4\ndigest: sha256:8cf531365742c7cab9628909dfe16958550853f7c994284eacad64f169f4c74a\nServiceAccount/podinfo/redis Current Resource is current\nConfigMap/podinfo/redis Current Resource is always ready\nService/podinfo/redis Current Service is ready\nService/podinfo/redis-readonly Current Service is ready\nDeployment/podinfo/redis-master Current Deployment is available. Replicas: 1\nDeployment/podinfo/redis-replica Current Deployment is available. Replicas: 1\nPersistentVolumeClaim/podinfo/redis-master Current PVC is Bound\n\nlast applied 2024-03-03T20:21:19Z\nmodule oci://ghcr.io/stefanprodan/modules/podinfo:6.5.4\ndigest: sha256:1dba385f9d56f9a79e5b87344bbec1502bd11f056df51834e18d3e054de39365\nServiceAccount/podinfo/podinfo Current Resource is always ready\nService/podinfo/podinfo Current Service is ready\nDeployment/podinfo/podinfo Current Deployment is available. Replicas: 1\n</code></pre> <p>List the instances in Bundle <code>podinfo</code> across all namespaces:</p> commandoutput <pre><code>timoni list --bundle podinfo -A\n</code></pre> <pre><code>NAME    NAMESPACE         MODULE                                          VERSION LAST APPLIED          BUNDLE\npodinfo podinfo           oci://ghcr.io/stefanprodan/modules/podinfo      6.5.4   2024-03-03T16:20:07Z  podinfo\nredis   podinfo           oci://ghcr.io/stefanprodan/modules/redis        7.2.4   2024-03-03T16:20:00Z  podinfo\n</code></pre>"},{"location":"bundle/#writing-a-bundle-spec","title":"Writing a Bundle spec","text":"<p>A Bundle file must contain a definition that matches the following schema:</p> <pre><code>#Bundle: {\n    apiVersion: string\n    name:       string\n    instances: [string]: {\n        module: {\n            url:     string\n            digest?: string\n            version: *\"latest\" | string\n        }\n        namespace: string\n        values: {...}\n    }\n}\n</code></pre> <p>Bundle files can contain arithmetic operations, string interpolation and everything else that CUE std lib supports.</p>"},{"location":"bundle/#api-version","title":"API version","text":"<p>The <code>apiVersion</code> is a required field that specifies the version of the Bundle schema.</p> <p>Currently, the only supported value is <code>v1alpha1</code>.</p>"},{"location":"bundle/#name","title":"Name","text":"<p>The <code>name</code> is a required field used to track the ownership of instances deployed to a Kubernetes cluster.</p> <p>Note that Bundles should have unique names per cluster, using the same name for different bundles will result in ownership conflict.</p>"},{"location":"bundle/#instances","title":"Instances","text":"<p>The <code>instances</code> array is a required field that specifies the list of Instances part of this Bundle.</p> <p>A Bundle must contain at least one instance with the following required fields:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"podinfo\"\n    instances: {\n        podinfo: {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/podinfo\"\n            namespace: \"podinfo\"\n        }\n    }\n}\n</code></pre>"},{"location":"bundle/#instance-module","title":"Instance Module","text":"<p>The <code>instance.module</code> is a required field that specifies the OCI URL, version and/or digest of the instance's module.</p>"},{"location":"bundle/#url","title":"URL","text":"<p>The <code>instance.module.url</code> is a required field that specifies the source of the module. It can be either an OCI repository address (preferred) or a local path to a module (useful during development).</p> <p>When using an OCI repository, the <code>url</code> field must be in the format <code>oci://&lt;registry-host&gt;/&lt;repo-name&gt;</code>.</p> <p>When using a Local path, the <code>url</code> field must be in the format <code>file://path/to/module</code>.</p> <p>Tip</p> <p>Relative paths are always computed relatively to the path of the bundle file containing the value.</p>"},{"location":"bundle/#version","title":"Version","text":"<p>The <code>instance.module.version</code> is an optional field that specifies the version number of the module. The version number must follow Timoni's semantic versioning. When not specified, the version defaults to <code>latest</code>, which pulls the module OCI artifact tagged as latest.</p> <pre><code>module: {\n    url:     \"oci://ghcr.io/stefanprodan/modules/podinfo\"\n    version: \"6.5.4\"\n}\n</code></pre> <p>Default version</p> <p>When not specified, the version defaults to <code>latest</code>, which pulls the module OCI artifact tagged as latest. Note that using <code>version: \"latest\"</code> is not recommended for production system, unless you also specify a digest.  </p>"},{"location":"bundle/#digest","title":"Digest","text":"<p>The <code>instance.module.digest</code> is an optional field that specifies the OCI digest of the module.</p> <pre><code>module: {\n    url:    \"oci://ghcr.io/stefanprodan/modules/podinfo\"\n    digest: \"sha256:1dba385f9d56f9a79e5b87344bbec1502bd11f056df51834e18d3e054de39365\"\n}\n</code></pre> <p>When both the version number and the digest are specified, Timoni will verify that the upstream digest of the version matches the specified <code>instance.module.digest</code>.</p> <pre><code>module: {\n    url:     \"oci://ghcr.io/stefanprodan/modules/podinfo\"\n    version: \"6.5.4\"\n    digest:  \"sha256:1dba385f9d56f9a79e5b87344bbec1502bd11f056df51834e18d3e054de39365\"\n}\n</code></pre> <p>If the version is set to <code>latest</code> and a digest is specified, Timoni will ignore the version and will pull the module by its OCI digest.</p>"},{"location":"bundle/#instance-namespace","title":"Instance Namespace","text":"<p>The <code>instance.namespace</code> is a required field that specifies the Kubernetes namespace where the instance is created.</p> <p>If the specified namespace does not exist, Timoni will first create the namespace, then it will apply the instance's resources in that namespace.</p>"},{"location":"bundle/#instance-values","title":"Instance Values","text":"<p>The <code>instance.values</code> is an optional field that specifies custom values used to configure the instance.</p> <p>At apply time, Timoni merges the custom values with the defaults, validates the final values against the config schema and creates the instance.</p>"},{"location":"bundle/#values-from-runtime","title":"Values from runtime","text":"<p>The <code>@timoni(runtime:[string|number|bool]:[VAR_NAME])</code> CUE attribute can be placed next to a field to set its value from the Runtime.</p> <pre><code>values: {\n    host:    \"example.com\" @timoni(runtime:string:MY_HOST)\n    enabled: true          @timoni(runtime:bool:MY_ENABLED)\n    score:   1             @timoni(runtime:number:MY_SCORE)\n}\n</code></pre> <p>To make a Runtime attribute required, the field value can be set to its type:</p> <pre><code>values: {\n    host:    string @timoni(runtime:string:MY_HOST)\n    enabled: bool   @timoni(runtime:bool:MY_ENABLED)\n    score:   int    @timoni(runtime:number:MY_SCORE)\n}\n</code></pre> <p>The Runtime values can come from Kubernetes API and/or from the environment variables, for more details please see the Bundle Runtime documentation.</p>"},{"location":"bundle/#working-with-bundles","title":"Working with Bundles","text":""},{"location":"bundle/#install-and-upgrade","title":"Install and Upgrade","text":"<p>To install or upgrade the instances defined in a Bundle file, you can use the <code>timoni bundle apply</code> command.</p> <p>Example:</p> <pre><code>timoni bundle apply -f bundle.cue\n</code></pre> <p>The apply command performs the following actions for each instance:</p> <ul> <li>Pulls the module version from the specified container registry.</li> <li>If the registry is private, uses the credentials found in <code>~/.docker/config.json</code>.</li> <li>If the registry credentials are specified with <code>--creds</code>, these take priority over the docker ones.</li> <li>Merges the custom values supplied in the Bundle with the default values found in the module.</li> <li>Builds the module by passing the instance name, namespace and values.</li> <li>Labels the resulting Kubernetes resources with the instance name and namespace.</li> <li>Creates the instance namespace if it doesn't exist.</li> <li>Applies the Kubernetes resources on the cluster.</li> <li>Creates or updates the instance inventory with the last applied resources IDs.</li> </ul>"},{"location":"bundle/#diff-upgrade","title":"Diff Upgrade","text":"<p>After editing a bundle file, you can review the changes that will be made on the cluster with <code>timoni bundle apply --diff</code>.</p> <p>Example:</p> <pre><code>timoni bundle apply --dry-run --diff -f bundle.cue\n</code></pre>"},{"location":"bundle/#force-upgrade","title":"Force Upgrade","text":"<p>If an upgrade contains changes to immutable fields, such as changing the image tag of a Kubernetes Job, you need to set the <code>--force</code> flag.</p> <p>Example:</p> <pre><code>timoni bundle apply --force -f bundle.cue\n</code></pre> <p>With <code>--force</code>, Timoni will recreate only the resources that contain changes to immutable fields.</p>"},{"location":"bundle/#transfer-ownership","title":"Transfer ownership","text":"<p>If an install or upgrade involves Instances already created, either separately or as a part of another Bundle, the operation will fail. To transfer ownership to the current Bundle, you need to set the <code>--overwrite-ownership</code> flag.</p> <p>Example:</p> <pre><code>timoni bundle apply --overwrite-ownership -f bundle.cue\n</code></pre>"},{"location":"bundle/#status","title":"Status","text":"<p>To list the current status of the managed resources for each instance including the last applied date, the module url and digest, you can use the <code>timoni bundle status</code>.</p> <p>Example using the bundle name:</p> <pre><code>timoni bundle status my-bundle\n</code></pre> <p>Example using a bundle CUE file:</p> <pre><code>timoni bundle status -f bundle.cue\n</code></pre>"},{"location":"bundle/#build","title":"Build","text":"<p>To build the instances defined in a Bundle file and print the resulting Kubernetes resources, you can use the <code>timoni bundle build</code> command.</p> <p>Example:</p> <pre><code>timoni bundle build -f bundle.cue\n</code></pre>"},{"location":"bundle/#use-values-from-json-and-yaml-files","title":"Use values from JSON and YAML files","text":"<p>A bundle can be defined in multiple files of different formats:</p> <pre><code>timoni bundle build -f bundle.cue -f extras1.json -f extras2.yaml\n</code></pre> <p>Timoni extracts the CUE values from the JSON and YAML files, and unifies them with the bundle value. Note that setting the same field in multiple files is not supported.</p> <p>Timoni supports the following extensions: <code>.cue</code>, <code>.json</code>, <code>.yml</code>, <code>.yaml</code>.</p>"},{"location":"bundle/#uninstall","title":"Uninstall","text":"<p>To uninstall all the instances belonging to a Bundle, you can use the <code>timoni bundle delete</code> command.</p> <p>Example using the bundle name:</p> <pre><code>timoni bundle delete my-bundle\n</code></pre> <p>Example using a bundle CUE file:</p> <pre><code>timoni bundle delete -f bundle.cue\n</code></pre> <p>Timoni will search the cluster and delete all the instances having the <code>bundle.timoni.sh/name: &lt;name&gt;</code> label matching the given bundle name. The instances are uninstalled in reverse order, first created instance is last to be deleted.</p>"},{"location":"bundle/#garbage-collection","title":"Garbage collection","text":"<p>Timoni's garbage collector keeps track of the applied resources and prunes the Kubernetes objects that were previously applied but are missing from the current revision.</p> <p>Example:</p> <pre><code>timoni bundle apply -f bundle.cue\n</code></pre> <p>To prevent the garbage collector from deleting certain resources such as Kubernetes Persistent Volumes, these resources can be annotated with <code>action.timoni.sh/prune: \"disabled\"</code>.</p>"},{"location":"bundle/#readiness-checks","title":"Readiness checks","text":"<p>By default, Timoni applies the instances in order, and will wait for each instance's resources to become ready, before moving to the next instance.</p> <p>The readiness check is performed for the Kubernetes resources with the following types:</p> <ul> <li>Kubernetes built-in kinds: Deployment, DaemonSet, StatefulSet,   PersistentVolumeClaim, Pod, PodDisruptionBudget, Job, CronJob, Service,   Secret, ConfigMap, CustomResourceDefinition</li> <li>Custom resources that are compatible   with kstatus</li> </ul> <p>Example:</p> <pre><code>timoni bundle apply --wait --timeout=5m -f bundle.cue\n</code></pre> <p>With <code>--timeout</code>, Timoni will retry the readiness checks until the specified timeout period expires. If an instance's resource fails to become ready, the apply command will exit with an error.</p> <p>The readiness check is enabled by default, to opt-out set <code>--wait=false</code>.</p>"},{"location":"bundle/#vetting","title":"Vetting","text":"<p>To verify that one or more CUE files contain a valid Bundle definition, you can use the <code>timoni bundle vet</code> command.</p> <p>Example:</p> <pre><code>timoni bundle vet -f bundle.cue -f extras.cue\n</code></pre> <p>If the validation passes, Timoni will list all the instances found in the computed bundle.</p> <p>When <code>--print-value</code> is specified, Timoni will write the Bundle computed value to stdout.</p> <p>Example:</p> <pre><code>timoni bundle vet -f bundle.cue --runtime-from-env --print-value\n</code></pre> <p>Printing the computed value is particular useful when debugging runtime attributes.</p>"},{"location":"bundle/#format","title":"Format","text":"<p>To format Bundle files, you can use the <code>cue fmt</code> command.</p> <p>Example:</p> <pre><code>cue fmt bundle.cue\n</code></pre>"},{"location":"bundle/#referencing-local-modules","title":"Referencing local modules","text":"<p>When developing and testing Timoni Modules, you can reference them from a Bundle file using relative local paths.</p> <p>Example repo structure:</p> <pre><code>\u251c\u2500\u2500 modules\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 app1\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 app2\n\u2514\u2500\u2500 bundles\n    \u2514\u2500\u2500 apps-test.cue\n</code></pre> <p>Example Bundle file:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"apps-test\"\n    instances: {\n        \"app1\": {\n            module: url: \"file://../modules/app1\"\n            namespace: \"app1\"\n            values: {...}\n        }\n        \"app2\": {\n            module: url: \"file://../modules/app2\"\n            namespace: \"app2\"\n            values: {...}\n        }\n    }\n}\n</code></pre> <p>When using local paths, the <code>url</code> field must be in the format <code>file://path/to/module</code> and the module path is computed relatively to the path of the bundle file location.</p> <p>Note that when using local modules, the module's version and digest are ignored, as these are only relevant when pulling modules from a container registry. All instances created from modules referenced with local paths have the module version set to <code>0.0.0-devel</code>.</p>"},{"location":"comparison/","title":"Timoni compared to other tools","text":""},{"location":"comparison/#helm","title":"Helm","text":"<p>If you are familiar with Helm, a Timoni module is the equivalent of a chart,  a Timoni bundle is the equivalent of an umbrella chart, and a Timoni instance is the equivalent of a Helm release.</p>"},{"location":"comparison/#authoring-differences","title":"Authoring differences","text":"<ul> <li>Instead of using charts, Timoni utilizes CUE modules distributed as OCI artifacts.</li> <li>Timoni modules can only be pushed and pulled to/from container registries.</li> <li>Timoni modules can be signed and verified with Cosign for integrity, unlike Helm's reliance on Helm provenance and OpenPGP signatures.</li> <li>Timoni works with CUE templates and CUE types generated from Kubernetes API Go types, eliminating the need for Go templating of Kubernetes YAML.</li> <li>Timoni leverages CUE types generated from Kubernetes CRDs for validating custom resources, eliminating the need for 3rd-party tooling like kubeconform.</li> <li>Timoni enables templating of CRDs, whereas Helm only supports plain YAML CRDs.</li> <li>Timoni allows authors to group Kubernetes resources and define the apply order for each group, instead of using Helm's pre/post install/upgrade hooks.</li> </ul>"},{"location":"comparison/#user-differences","title":"User differences","text":"<ul> <li>Timoni expects users to provide values as CUE definitions instead of supplying them in YAML format.</li> <li>Unlike Helm, Timoni allows condition statements in values and bundle files, enabling users to express logic using CUE.</li> <li>Timoni employs Kubernetes server-side apply and Flux's drift detection instead of Helm's client-side apply.</li> <li>Timoni patches only the Kubernetes objects that have changed during upgrades, while Helm applies all manifests.</li> <li>Timoni applies resources in stages, ensuring readiness for each resource group before proceeding to the next one (e.g., CRDs and namespaces, then workloads, then custom resources).</li> <li>Timoni supports upgrading CRDs and their controllers, unlike Helm, which ignores changes to CRDs.</li> <li>Timoni's garbage collector can delete CRDs and PVCs, whereas Helm leaves them on the cluster during uninstallation.</li> <li>Timoni performs health checks on Kubernetes custom resources, which Helm ignores.</li> <li>Unlike Helm, Timoni doesn't require keeping a copy of all YAML manifests in a Kubernetes secret, eliminating the limit on the number of objects constituting an application.</li> <li>Timoni provides a <code>apply --diff</code> command for displaying a preview of the cluster state changes for an upgrade.</li> <li>Timoni Bundles offer a declarative way of grouping multiple apps into a deployable unit, serving as an alternative to Helm's umbrella charts.</li> <li>Timoni Runtime API offers a way to define values which are fetched from the Kubernetes API (ConfigMaps, Secrets, Custom Resources) and mapped to fields inside a Bundle. </li> <li>Timoni modules can be referenced by their OCI SHA256 digest, ensuring immutability and reproducibility, unlike Helm charts that are referenced only by version.</li> </ul>"},{"location":"concepts/","title":"Concepts","text":"<ul> <li>Module - App definition containing Kubernetes CUE templates and configuration schema, distributed as OCI artifacts.</li> <li>Instance - App instantiation referencing the module and workloads deployed on a Kubernetes cluster.</li> <li>Bundle - App composition bundling multiple modules and configurations into a deployable unit.</li> <li>Artifact - Packaging format used for distributing modules and bundles to container registries.</li> </ul>"},{"location":"concepts/#module","title":"Module","text":"<p>A Timoni module contains a set of CUE definitions and constraints organised into a CUE module with an opinionated structure.</p> <p>A module accepts a set of values supplied by users, and outputs a set of Kubernetes objects that Timoni deploys on Kubernetes clusters.</p> <p>Commands for working with local modules:</p> <ul> <li><code>timoni mod init &lt;module-name&gt;</code></li> <li><code>timoni mod vet &lt;path/to/module&gt;</code></li> <li><code>timoni build &lt;name&gt; &lt;path/to/module&gt; -n &lt;namespace&gt;</code></li> <li><code>timoni apply &lt;name&gt; &lt;path/to/module&gt; -f &lt;path/to/values.cue&gt; --dry-run --diff</code></li> </ul> <p>Commands for vendoring Kubernetes APIs and CRDs:</p> <ul> <li><code>timoni mod vendor k8s --version latest</code></li> <li><code>timoni mod vendor crds -f &lt;path/to/crds.yaml&gt;</code></li> </ul> <p>Timoni modules are distributed as OCI artifacts that can be cryptographically signed and verified. Modules are versioned using strict semantic versioning, the version of a module is used as the OCI artifact tag.</p> <p>To learn more about modules, please see the module documentation.</p>"},{"location":"concepts/#instance","title":"Instance","text":"<p>A Timoni instance represent a module instantiation on a Kubernetes cluster. A module can be installed multiple times on a cluster by giving its instances unique names per namespace.</p> <p>When instantiating a module, users can supply their own <code>values.cue</code> that gets merged with the defaults included in the module:</p> <pre><code>values: {\n    ingress: {\n        enabled:   true\n        className: \"nginx\"\n        host:      \"app.example.com\"\n    }\n    autoscaling: enabled: true\n    monitoring: enabled:  true\n}\n</code></pre> <p>Commands for working with module instances:</p> <ul> <li><code>timoni install &lt;name&gt; oci://&lt;module-url&gt; -v &lt;semver&gt; -n &lt;namespace&gt;</code></li> <li><code>timoni upgrade &lt;name&gt; oci://&lt;module-url&gt; -v &lt;semver&gt; -f &lt;path/to/values.cue&gt;</code></li> <li><code>timoni uninstall &lt;name&gt; -n &lt;namespace&gt;</code></li> <li><code>timoni list -n &lt;namespace&gt;</code></li> <li><code>timoni inspect [module|values|resources] &lt;name&gt; -n &lt;namespace&gt;</code></li> <li><code>timoni status &lt;name&gt; -n &lt;namespace&gt;</code></li> </ul> <p>The <code>install</code> and <code>upgrade</code> commands are aliases of <code>timoni apply</code>. To apply the Kubernetes resources belonging to a module instance, Timoni uses Kubernetes server-side apply and Flux's drift detection.</p> <p>The apply command validates all resources with a dry-run apply, and reconciles only the ones with changes to the cluster state.</p> <p>Timoni's garbage collector keeps track of the applied resources and prunes the Kubernetes objects that were previously applied but are missing from the current revision.</p> <p>After an installation or upgrade, Timoni waits for the applied resources to be fully reconciled by checking the ready status of deployments, jobs, services, ingresses, and Kubernetes custom resources.</p>"},{"location":"concepts/#bundle","title":"Bundle","text":"<p>Timoni bundles offer a declarative way of managing the lifecycle of applications and their infra dependencies.</p> <p>A Timoni bundle is a CUE file for defining a group of instances together with their values and module references:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"podinfo\"\n    instances: {\n        redis: {\n            module: {\n                url:     \"oci://ghcr.io/stefanprodan/modules/redis\"\n                version: \"7.0.9\"\n            }\n            namespace: \"podinfo\"\n            values: maxmemory: 256\n        }\n        podinfo: {\n            module: url:     \"oci://ghcr.io/stefanprodan/modules/podinfo\"\n            module: version: \"6.3.4\"\n            namespace: \"podinfo\"\n            values: caching: {\n                enabled:  true\n                redisURL: \"tcp://redis:6379\"\n            }\n        }\n    }\n}\n</code></pre> <p>For deterministic operations, it is possible to pin a module version by its OCI digest:</p> <pre><code>redis: {\n    module: {\n        url:    \"oci://ghcr.io/stefanprodan/modules/redis\"\n        digest: \"sha256:e9137d41b0d263bfaf2a43fc862648ad9dc3a976b4b0fc6e27617ea28ee27d45\"\n    }\n}\n</code></pre> <p>Bundle example</p> <p>An example bundle can be found in Timoni's repository at examples/bundles/podinfo.cue. This bundle defines a Redis master-replica cluster and a podinfo instance connected to the Redis instance. The secret values are defined in a separate file which can be kept encrypted or pulled from a secure vault at apply time.</p> <p>In the bundle files you can use arithmetic operations, string interpolation and everything else that CUE std lib supports.</p> <p>Commands for working with bundles:</p> <ul> <li><code>timoni bundle apply -f bundle.cue --runtime runtime.cue --diff</code></li> <li><code>timoni bundle build -f bundle.cue -f bundle_extras.cue</code></li> <li><code>timoni bundle delete -f bundle.cue</code></li> <li><code>timoni bundle vet -f bundle.cue</code></li> </ul> <p>To learn more about bundles, please see the Bundle API documentation and the Bundle Runtime API documentation.</p>"},{"location":"concepts/#artifact","title":"Artifact","text":"<p>Timoni modules and bundles are distributed to container registries as Open Container Initiative (OCI) artifacts.</p> <p>The OCI artifacts produced by Timoni have the following media types:</p> <ul> <li>Image media type <code>application/vnd.oci.image.manifest.v1+json</code></li> <li>Config media type <code>application/vnd.timoni.config.v1+json</code></li> <li>Layer media type <code>application/vnd.timoni.content.v1.tar+gzip</code></li> </ul> <p>To enable reproducible builds, Timoni sets the artifact's last modified date, the source URL and source revision annotations from the Git metadata.</p> <p>Commands for managing the authentication to container registries:</p> <ul> <li><code>timoni registry login &lt;registy-host&gt; -u &lt;user&gt; -p &lt;password&gt;</code></li> <li><code>timoni registry logout &lt;registy-host&gt;</code></li> </ul> <p>Commands for distributing modules:</p> <ul> <li><code>timoni mod push &lt;path/to/module&gt; oci://&lt;module-url&gt; -v &lt;semver&gt; --sign</code></li> <li><code>timoni mod pull oci://&lt;module-url&gt; -v &lt;semver&gt; -o &lt;path/to/module&gt; --verify</code></li> <li><code>timoni mod list oci://&lt;module-url&gt;</code></li> </ul> <p>Commands for distributing bundles and runtimes:</p> <ul> <li><code>timoni artifact push oci://&lt;artifact-url&gt; -t &lt;tag&gt; -f &lt;path/to/dir&gt;</code></li> <li><code>timoni artifact pull oci://&lt;artifact-url&gt; -o &lt;path/to/dir&gt;</code></li> <li><code>timoni artifact list oci://&lt;artifact-url&gt;</code></li> <li><code>timoni artifact tag oci://&lt;artifact-url&gt;:&lt;tag&gt; -t &lt;new-tag&gt;</code></li> </ul>"},{"location":"flux-aio/","title":"Flux AIO Distribution","text":"<p>Flux All-In-One is a lightweight Flux CD distribution made with Timoni for running the GitOps Toolkit controllers as a single deployable unit.</p> <p>Helm charts interoperability</p> <p>Flux AIO can be used as a bridge between Timoni and Helm, enabling Timoni to orchestrate Helm chart deployments by leveraging Flux's declarative Helm APIs. For more information see the Helm interoperability guide.</p>"},{"location":"flux-aio/#specifications","title":"Specifications","text":"<p>This distribution is optimized for running Flux on:</p> <ul> <li>Edge clusters with limited CPU and memory resources</li> <li>Bare clusters without a CNI plugin installed</li> <li>Clusters where plain HTTP communication is not allowed between pods</li> <li>Serverless clusters for cost optimisation (EKS Fargate, GKE Autopilot)</li> </ul> <p>Timoni modules part of this distribution:</p> <ul> <li>flux-aio - A module for deploying    Flux core components such as source-controller, helm-controller, kustomize-controller and notification-controller.</li> <li>flux-oci-sync - A module for   configuring Flux to deploy workloads from OCI artifacts.</li> <li>flux-git-sync - A module for    configuring Flux to deploy workloads from Git repositories.</li> <li>flux-helm-release - A module for   configuring Flux to deploy Helm releases from charts hosted on Helm HTTP/S and OCI repositories.</li> <li>flux-tenant - A module for   onboarding tenants with limited access on Flux-managed clusters.</li> </ul>"},{"location":"flux-aio/#flux-installation","title":"Flux installation","text":"<p>To deploy Flux on Kubernetes clusters, you'll be using the flux-aio module and a Bundle file where you'll define the configuration of the Flux controllers and their settings.</p> Default installationBare MetalCloud <p>Install Flux with default settings on a Kubernetes cluster:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"flux-aio\"\n    instances: {\n        \"flux\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-aio\"\n            namespace: \"flux-system\"\n            values: {\n                controllers: {\n                    helm: enabled:         true\n                    kustomize: enabled:    true\n                    notification: enabled: true\n                }\n                hostNetwork:     false\n                securityProfile: \"privileged\"\n            }\n        }\n    }\n}\n</code></pre> <p>Apply the bundle with:</p> <pre><code>timoni bundle apply -f flux-aio.cue\n</code></pre> <p>You can fine tune the Flux installation using various options listed in the flux-aio module readme.</p> <p>To install Flux on a bare metal cluster, you need to set <code>hostNetwork: true</code> in the  flux-aio module values.</p> <p>For example, to deploy Flux and configure it to install the latest version of the Cilium CNI:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"flux-aio\"\n    instances: {\n        \"flux\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-aio\"\n            namespace: \"flux-system\"\n            values: {\n                hostNetwork:     true\n                securityProfile: \"privileged\"\n            }\n        }\n        \"cilium\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-helm-release\"\n            namespace: \"flux-system\"\n            values: {\n                repository: url: \"https://helm.cilium.io\"\n                chart: {\n                    name:    \"cilium\"\n                    version: \"*\"\n                }\n                helmValues: {\n                    operator: replicas: 1\n                    ipam: mode:         \"kubernetes\"\n                }\n                sync: targetNamespace: \"kube-system\"\n            }\n        }\n    }\n}\n</code></pre> <p>The Flux pod binds to the following ports on the host network:</p> <ul> <li><code>9292</code> notification-controller webhook receiver endpoint</li> <li><code>9690</code> notification-controller events receiver endpoint</li> <li><code>9790</code> source-controller storage endpoint</li> <li><code>9791-9799</code> metrics, liveness and readiness endpoints</li> </ul> <p>Note that on clusters without <code>kube-proxy</code>, you'll have to add the following env vars to values:</p> <pre><code>values: env: {\n    \"KUBERNETES_SERVICE_HOST\": \"&lt;host&gt;\"\n    \"KUBERNETES_SERVICE_PORT\": \"&lt;port&gt;\"\n}\n</code></pre> <p>When installing Flux on a managed Kubernetes cluster, the host network can be disabled if the cloud vendor has already setup a CNI for you. You can also configure persistent storage for Flux artifacts cache to speed up the startup after a pod eviction.</p> <p>To grant Flux access to cloud resources such as container registries (for pulling OCI artifacts) or KMS (for secretes decryption), you can use Kubernetes Workload Identity to bind the <code>flux</code> service account from the <code>flux-system</code> namespace to an IAM role.</p> <p>For example, on an EKS cluster with IRSA enabled, grant Flux access to ECR by specified an AWS role ARN:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"flux-aio\"\n    instances: {\n        \"flux\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-aio\"\n            namespace: \"flux-system\"\n            values: {\n                hostNetwork:     false\n                securityProfile: \"privileged\"\n                workload: {\n                    identity: \"arn:aws:iam::111122223333:role/my-role\"\n                    provider: \"aws\"\n                }\n                persistence: {\n                    enabled:      true\n                    storageClass: \"standard\"\n                    size:         \"8Gi\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>For Azure Workload Identity, the type must be set to <code>azure</code> and the identity set to the Azure Client ID.</p> <p>For Google Cloud, the type must be set to <code>gcp</code> and the identity set to the GCP Identity Name.</p>"},{"location":"flux-aio/#flux-upgrade","title":"Flux upgrade","text":"<p>To upgrade Flux to the latest version, you can rerun the <code>timoni bundle apply -f flux-aio.cue</code> command, and Timoni will check if a newer version of the <code>flux-aio</code> module is available and apply the changes.</p> <p>To upgrade Flux to a specific version, you can specify the version in the <code>module.version</code> field:</p> <pre><code>module: {\n    url:     \"oci://ghcr.io/stefanprodan/modules/flux-aio\"\n    version: \"2.5.0-0\"\n}\n</code></pre> <p>Flux AIO versioning</p> <p>The versioning of the AIO distribution follows semver with the following format: <code>&lt;flux version&gt;-&lt;distribution release number&gt;</code>, e.g. <code>2.5.0-3</code>.</p> <p>To list all available versions of the <code>flux-aio</code> module, you can use the <code>timoni mod ls</code> command, or you can check the flux-aio release page.</p>"},{"location":"flux-aio/#flux-oci-sync-configuration","title":"Flux OCI sync configuration","text":"<p>To configure Flux to deploy workloads from OCI artifacts hosted on container registries, you'll be using the flux-oci-sync module.</p> <p>This module generates Flux <code>OCIRepository</code> and <code>Kustomization</code> objects and allows the configuration of the OCI artifact URL, auth credentials, tag, interval, substitutions, health checks.</p> Public repositoryPrivate repository <p>To configure Flux to sync with a public OCI repository, you have to specify the OCI address of the repository, the tag or semver range, and optionally you can enable waiting for the workloads to become ready.</p> <p>For example, to sync the podinfo Kustomize overlay to the <code>default</code> namespace:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"podinfo\"\n    instances: {\n        \"podinfo\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-oci-sync\"\n            namespace: \"flux-system\"\n            values: {\n                artifact: {\n                    url:    \"oci://ghcr.io/stefanprodan/manifests/podinfo\"\n                    semver: \"&gt;=1.0.0\"\n                }\n                sync: {\n                    targetNamespace: \"default\"\n                    wait:            true\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Apply the bundle with:</p> <pre><code>timoni bundle apply -f podinfo.cue\n</code></pre> <p>You can fine tune the sync using the options listed in the flux-oci-sync module readme.</p> <p>To configure Flux to sync from a private container registry, you can specify the registry credentials that will be persisted in the cluster as a Kubernetes Secret of type <code>dockerconfigjson</code>.</p> <p>To avoid storing sensitive information in your bundle files, Timoni can read values from environment variable.</p> <p>For example, to sync podinfo from your own private repo:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"podinfo\"\n    instances: {\n        \"podinfo\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-oci-sync\"\n            namespace: \"flux-system\"\n            values: {\n                artifact: {\n                    auth: credentials: {\n                        username: \"flux\"\n                        password: string @timoni(runtime:string:GCHR_TOKEN)\n                    }\n                    url: \"oci://ghcr.io/stefanprodan/manifests/podinfo\"\n                    tag: \"latest\"\n                }\n                sync: targetNamespace: \"default\"\n            }\n        }\n    }\n}\n</code></pre> <p>Assuming the <code>GCHR_TOKEN</code> is set in your environment, apply the bundle using the <code>--runtime-from-env</code> flag and Timoni will fill in the password value:</p> <pre><code>timoni bundle apply -f podinfo.cue --runtime-from-env\n</code></pre>"},{"location":"flux-aio/#flux-git-sync-configuration","title":"Flux Git sync configuration","text":"<p>To configure Flux to deploy workloads from a Git repository, you'll be using the flux-git-sync module.</p> <p>This module generates Flux <code>GitRepository</code> and <code>Kustomization</code> objects and allows the configuration of the Git HTTPS URL, auth token, branch, path, interval, health checks.</p> Public repositoryPrivate repositoryGitHub App authSelf-hosted repository <p>To configure Flux to sync with a public Git repository, you have to specify the Git HTTPS address of the repository, the Git ref (can be a branch or tag) and the path to the Kubernetes manifests or to the Kustomize overlay.</p> <p>For example, to sync the podinfo Kustomize overlay to the <code>default</code> namespace:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"podinfo\"\n    instances: {\n        \"podinfo\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-git-sync\"\n            namespace: \"flux-system\"\n            values: {\n                git: {\n                    url:  \"https://github.com/stefanprodan/podinfo\"\n                    ref:  \"refs/heads/master\"\n                    path: \"./kustomize\"\n                }\n                sync: targetNamespace: \"default\"\n            }\n        }\n    }\n}\n</code></pre> <p>Apply the bundle with:</p> <pre><code>timoni bundle apply -f podinfo.cue\n</code></pre> <p>You can fine tune the sync using the options listed in the flux-git-sync module readme.</p> <p>To configure Flux to sync with a private Git repository, you can specify a Git token (GitHub PAT, GitLab deploy token, BitBucket token, etc).</p> <p>To avoid storing sensitive information in your bundle files, Timoni can read values from environment variable.</p> <p>For example, to sync podinfo from your own private repo:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"podinfo\"\n    instances: {\n        \"podinfo\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-git-sync\"\n            namespace: \"flux-system\"\n            values: {\n                git: {\n                    token: string @timoni(runtime:string:GITHUB_TOKEN)\n                    url:   \"https://github.com/my-org/my-private-repo\"\n                    ref:   \"refs/heads/master\"\n                    path:  \"./kustomize\"\n                }\n                sync: targetNamespace: \"default\"\n            }\n        }\n    }\n}\n</code></pre> <p>Assuming the <code>GITHUB_TOKEN</code> is set in your environment, apply the bundle using the <code>--runtime-from-env</code> flag and Timoni will fill in the token value:</p> <pre><code>timoni bundle apply -f podinfo.cue --runtime-from-env\n</code></pre> <p>To configure Flux to sync with a private GitHub repository using GitHub App authentication:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"cluster-addons\"\n    instances: {\n        \"flux-system\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-git-sync\"\n            namespace: \"flux-system\"\n            values: {\n                git: {\n                    url:  \"https://github.com/org/repo\"\n                    ref:  \"refs/heads/main\"\n                    path: \"./deploy/cluster-addons\"\n                }\n                github: {\n                    appID:             \"123\"\n                    appInstallationID: \"234\"\n                    appPrivateKey:     string @timoni(runtime:string:GITHUB_APP_PEM)\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Export the <code>GITHUB_APP_PEM</code> env var and apply the bundle using the <code>--runtime-from-env</code> flag:</p> <pre><code>export GITHUB_APP_PEM=$(cat path/to/app.private-key.pem)\n\ntimoni bundle apply -f cluster-addons.cue --runtime-from-env\n</code></pre> <p>When using a self-hosted Git server such as GitLab, the self-signed TLS Certificate Authority must be specified for Flux to be able to sync the repository.</p> <p>For example, to sync podinfo from a self-hosted private repo:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"podinfo\"\n    instances: {\n        \"podinfo\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-git-sync\"\n            namespace: \"flux-system\"\n            values: {\n                git: {\n                    ca:    string @timoni(runtime:string:GIT_CA)\n                    token: string @timoni(runtime:string:GIT_TOKEN)\n                    url:   \"https://gitlab.internal/my-group/my-repo\"\n                    ref:   \"refs/heads/master\"\n                    path:  \"./kustomize\"\n                }\n                sync: targetNamespace: \"default\"\n            }\n        }\n    }\n}\n</code></pre> <p>Export the <code>GIT_TOKEN</code> and <code>GIT_CA</code> env vars, then apply the bundle:</p> <pre><code>export GIT_CA=$(cat ca.crt)\nexport GIT_TOKEN=\"your-token\"\n\ntimoni bundle apply -f podinfo.cue --runtime-from-env\n</code></pre> <p>Note that the CA certificate must be PEM-encoded.</p>"},{"location":"flux-aio/#flux-multi-tenancy-configuration","title":"Flux multi-tenancy configuration","text":"<p>To enable Flux multi-tenancy lockdown, you can set <code>securityProfile: \"restricted\"</code> in the flux-aio values.</p> <p>With the restricted profile, Flux Kustomizations and HelmReleases can't create cluster-wide resources (CRDs, Namespaces, ClusterRoleBindings, etc) unless they are deployed in the <code>flux-system</code> namespace. The <code>flux-system</code> namespace, like <code>kube-system</code>, is reserved to cluster admins.</p>"},{"location":"flux-aio/#on-board-tenants","title":"On-board tenants","text":"<p>To configure Flux to deploy workloads from a tenant repository, you'll be using the <code>flux-tenant</code> and  <code>flux-git-sync</code> Timoni modules.</p> <p>The <code>flux-tenant</code> module generates the tenant's Kubernetes namespace and RBAC (service account &amp; role binding) that constrains Flux to be able to deploy applications only in that namespace.</p> <p>The <code>flux-git-sync</code> module configures Flux to reconcile the tenant's Kubernetes resources from their Git repository while impersonating the restricted service account.</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"dev-team\"\n    instances: {\n        \"dev-team\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-tenant\"\n            namespace: \"dev-team-apps\"\n            values: {\n                role: \"namespace-admin\"\n                resourceQuota: {\n                    kustomizations: 100\n                    helmreleases:   100\n                }\n            }\n        }\n        \"dev-team-apps\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-git-sync\"\n            namespace: \"dev-team-apps\"\n            values: {\n                git: {\n                    token: string @timoni(runtime:string:DEVTEAM_TOKEN)\n                    url:   \"https://github.com/org/dev-team-apps\"\n                    ref:   \"refs/heads/main\"\n                    path:  \"./deploy\"\n                }\n                sync: targetNamespace: namespace\n            }\n        }\n    }\n}\n</code></pre> <p>On-board the tenant with:</p> <pre><code>export DEVTEAM_TOKEN=&lt;GH TOKEN&gt;\ntimoni bundle apply -f dev-team.cue --runtime-from-env\n</code></pre>"},{"location":"flux-aio/#off-board-tenants","title":"Off-board tenants","text":"<p>Off-board the tenant and remove all their workloads with:</p> <pre><code>timoni bundle delete dev-team\n</code></pre>"},{"location":"flux-helm-interop/","title":"Helm interoperability with Flux","text":"<p>Flux AIO can be used as a bridge between Timoni and Helm, enabling Timoni to orchestrate Helm chart deployments by leveraging Flux's declarative Helm APIs such as <code>HelmRepository</code> and <code>HelmRelease</code> kinds.</p> <p>With Flux, Timoni users can take full advantage of existing Helm charts. Timoni Bundles can refer to Helm charts hosted on Helm HTTPS and OCI repositories, and supports setting Helm release values in the same way you would do for Timoni instances.</p>"},{"location":"flux-helm-interop/#install-flux-helm-controller","title":"Install Flux helm-controller","text":"<p>Install Flux helm-controller on a Kubernetes cluster with:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"flux-aio\"\n    instances: {\n        \"flux\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-aio\"\n            namespace: \"flux-system\"\n            values: {\n                controllers: {\n                    helm: enabled:         true\n                    kustomize: enabled:    false\n                    notification: enabled: false\n                }\n                hostNetwork:     false\n                securityProfile: \"privileged\"\n            }\n        }\n    }\n}\n</code></pre> <p>Apply the bundle with:</p> <pre><code>timoni bundle apply -f flux-aio.cue\n</code></pre>"},{"location":"flux-helm-interop/#deploy-helm-charts","title":"Deploy Helm charts","text":"<p>To deploy Helm charts on clusters with Flux installed, you'll be using the flux-helm-release Timoni module. This module generates Flux <code>HelmRepository</code> and <code>HelmRelease</code> objects and allows the configuration of the Helm repository HTTP/S or OCI URL, auth token, chart name, and Helm release values.</p>"},{"location":"flux-helm-interop/#public-repositories","title":"Public repositories","text":"<p>Example of deploying <code>cert-manager</code> and <code>ingress-nginx</code> Helm charts to a Kubernetes cluster:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"cluster-addons\"\n    instances: {\n        \"cert-manager\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-helm-release\"\n            namespace: \"cert-manager\"\n            values: {\n                repository: url: \"https://charts.jetstack.io\"\n                chart: {\n                    name:    \"cert-manager\"\n                    version: \"1.x\"\n                }\n                helmValues: {\n                    installCRDs: true\n                }\n            }\n        }\n        \"ingress-nginx\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-helm-release\"\n            namespace: \"ingress-nginx\"\n            values: {\n                repository: url: \"https://kubernetes.github.io/ingress-nginx\"\n                chart: {\n                    name:    \"ingress-nginx\"\n                    version: \"4.x\"\n                }\n                helmValues: {\n                    controller: service: type: \"NodePort\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Apply the bundle with:</p> <pre><code>timoni bundle apply -f cluster-addons.cue\n</code></pre> <p>Timoni will create the Flux Helm repositories, will wait for Flux to install the <code>cert-manager</code> release, then will proceed with the <code>ingress-nginx</code> installation.</p> <p>After the releases are installed, Flux will scan for new chart versions every hour, and will upgrade a release if a new chart version is found. To disable the automated upgrade, you can set a fix version for each chart under <code>values: chart: version</code>.</p>"},{"location":"flux-helm-interop/#private-repositories","title":"Private repositories","text":"<p>When using Helm charts from a private Helm HTTPS or OCI repository, you can provide the auth credentials in the Bundle using Timoni runtime attributes.</p> <p>Example of deploying the <code>podinfo</code> Helm chart from GitHub Container Registry using a GitHub PAT for auth:</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"podinfo\"\n    instances: {\n        \"podinfo\": {\n            module: url: \"oci://ghcr.io/stefanprodan/modules/flux-helm-release\"\n            namespace: \"podinfo\"\n            values: {\n                repository: {\n                    url: \"oci://ghcr.io/stefanprodan/charts\"\n                    auth: {\n                        username: \"flux\"\n                        password: string @timoni(runtime:string:GITHUB_TOKEN)\n                    }\n                }\n                chart: {\n                    name:    \"podinfo\"\n                    version: \"*\"\n                }\n                helmValues: {\n                    logLevel: \"info\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Assuming the <code>GITHUB_TOKEN</code> is set in your environment, apply the bundle using the <code>--runtime-from-env</code> flag and Timoni will fill in the token value:</p> <pre><code>timoni bundle apply -f podinfo.cue --runtime-from-env\n</code></pre> <p>Timoni will create a Kubernetes Secret with the Helm credentials, and will configure Flux to use the Secret when pulling the Helm OCI charts from the container registry.</p>"},{"location":"github-actions/","title":"GitHub Actions","text":"<p>Timoni can be used in GitHub workflows to perform actions such as build, test and push modules to container registries.</p>"},{"location":"github-actions/#usage","title":"Usage","text":"<p>To run Timoni commands on GitHub Linux runners, add the following steps to your GitHub workflow:</p> <pre><code>steps:\n  - name: Setup Timoni\n    uses: stefanprodan/timoni/actions/setup@main\n    with:\n      version: latest # latest or exact version e.g. 0.13.0\n  - name: Run Timoni\n    run: timoni version\n</code></pre>"},{"location":"github-actions/#examples","title":"Examples","text":""},{"location":"github-actions/#push-to-github-container-registry","title":"Push to GitHub Container Registry","text":"<p>Example workflow for linting, testing and pushing a module to GitHub Container Registry:</p> <pre><code>name: Release module\non:\n  push:\n    tags: ['*'] # semver format\n\npermissions:\n  contents: read # needed for checkout\n  packages: write # needed for GHCR access\n\njobs:\n  push:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Setup Timoni\n        uses: stefanprodan/timoni/actions/setup@main\n      - name: Lint\n        run: |\n          timoni mod lint ./my-module\n      - name: Test instance build\n        run: |\n          timoni build -n testing test ./my-module\n      - name: Push\n        run: |\n          timoni mod push ./my-module \\\n            oci://ghcr.io/${{ github.repository_owner }}/my-module \\\n            --version ${{ github.ref_name }} \\\n            --creds ${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}\n            --latest \\\n            -a 'org.opencontainers.image.licenses=Apache-2.0' \\\n            -a 'org.opencontainers.image.source=https://github.com/${{ github.repository }}' \\\n            -a 'org.opencontainers.image.description=My Timoni module.' \n</code></pre>"},{"location":"github-actions/#push-and-sign-with-cosign-keyless","title":"Push and sign with Cosign Keyless","text":"<p>Example workflow for pushing and signing the module using Cosign and GitHub OIDC:</p> <pre><code>name: Release and sign module\non:\n  push:\n    tags: ['*'] # semver format\n\npermissions:\n  contents: read # needed for checkout\n  packages: write # needed for GHCR access\n  id-token: write # needed for signing\n\njobs:\n  push:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Setup Cosign\n        uses: sigstore/cosign-installer@main\n      - name: Setup Timoni\n        uses: stefanprodan/timoni/actions/setup@main\n      - name: Login to GHCR\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n      - name: Push and Sign\n        run: |\n          timoni mod push ./my-module \\\n            oci://ghcr.io/${{ github.repository_owner }}/my-module \\\n            --version ${{ github.ref_name }} \\\n            --latest \\\n            -a 'org.opencontainers.image.licenses=Apache-2.0' \\\n            -a 'org.opencontainers.image.source=https://github.com/${{ github.repository }}' \\\n            -a 'org.opencontainers.image.description=My Timoni module.' \\\n            --sign=cosign\n</code></pre>"},{"location":"github-actions/#push-to-docker-hub","title":"Push to Docker Hub","text":"<p>Example workflow for using <code>docker login</code> to authenticate to Docker Hub:</p> <pre><code>name: Release module\non:\n  push:\n    tags: ['*'] # semver format\n\npermissions:\n  contents: read # needed for checkout\n\njobs:\n  push:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Setup Timoni\n        uses: stefanprodan/timoni/actions/setup@main\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          registry: docker.io\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n      - name: Push\n        run: |\n          timoni mod push ./my-module \\\n            oci://docker.io/my-org/my-module \\\n            --version ${{ github.ref_name }}\n            --latest \\\n            -a 'org.opencontainers.image.licenses=Apache-2.0' \\\n            -a 'org.opencontainers.image.source=https://github.com/${{ github.repository }}' \\\n            -a 'org.opencontainers.image.description=My Timoni module.' \n      - name: Pull\n        run: |\n          mkdir -p /tmp/my-module\n          timoni mod pull oci://docker.io/my-org/my-module \\\n            --version ${{ github.ref_name }} \\\n            --output /tmp/my-module\n</code></pre> <p>Note that docker/login-action can be used to authenticate to any private registry including ACR, ECR, GCR.</p>"},{"location":"gitops-flux/","title":"GitOps Guide","text":"<p>This guide shows you how Timoni can be used together with Flux to create a GitOps delivery pipeline for module instances.</p> <pre><code>flowchart LR\n\nA((User)) --&gt; Y\nY(Module Values) --&gt; B((Timoni))\nB --&gt; D[Container Registry]\nD --&gt; E((Flux CD))\nE --&gt; F[Kubernetes]</code></pre> <p>Timoni Controller</p> <p>Note that currently Timoni can be used with Flux as a templating engine for Kubernetes manifests. Features like app lifecycle management, bundling, runtime values injection and multi-cluster deployments are not available when using Timoni as a templating engine. For Timoni to fully embrace GitOps, a Kubernetes controller will be implemented when Timoni's CUE APIs reach a more stable form.</p>"},{"location":"gitops-flux/#build-and-push-workflow","title":"Build and Push workflow","text":"<p>We'll build a module instance with Timoni, and we'll push  the resulting Kubernetes manifests to a container registry with Flux CLI.</p> <pre><code>timoni -n apps build podinfo oci://ghcr.io/stefanprodan/modules/podinfo \\\n  --values ./staging-values.cue | \\\nflux push artifact oci://registry.internal/podinfo:staging \\\n  --source=\"http://github.com/stefanprodan/podinfo\" \\\n  --revision=\"6.3.4\" \\\n  --path=-\n</code></pre> <p>You can also use a Timoni bundle to generate the Kubernetes manifests:</p> <pre><code>timoni bundle build -f podinfo.cue | \\\nflux push artifact oci://registry.internal/podinfo:staging \\\n  --source=\"http://github.com/stefanprodan/podinfo\" \\\n  --revision=\"6.3.4\" \\\n  --path=-\n</code></pre> <p>The above commands could be run in CI for the Git repository that contains the values files. Committing a change to the values, will result in a new artifact pushed to the registry. From there, Flux running in Kubernetes, will pick up the latest changes and deploy them on the cluster.</p>"},{"location":"gitops-flux/#continuous-delivery-workflow","title":"Continuous Delivery workflow","text":"<p>In the Git repository where Flux was bootstrapped, we'll configure the reconciliation of the Kubernetes resources pushed to the container registry.</p> <p>Flux sync module</p> <p>You can generate the configuration for Flux to reconcile the OCI artifacts using the flux-oci-sync module.</p> <pre><code>---\napiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: OCIRepository\nmetadata:\n  name: podinfo\n  namespace: flux-system\nspec:\n  interval: 1m\n  url: oci://registry.internal/podinfo\n  ref:\n    tag: staging\n---\napiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nkind: Kustomization\nmetadata:\n  name: podinfo\n  namespace: flux-system\nspec:\n  targetNamespace: apps\n  interval: 1h\n  retryInterval: 30s\n  timeout: 5m\n  path: ./\n  prune: true\n  wait: true\n  sourceRef:\n    kind: OCIRepository\n    name: podinfo\n</code></pre> <p>Based on the above configuration, Flux will look for changes in the container registry every minute. When it finds a new digest of the OCI artifact, Flux will automatically reconcile the changes on the cluster.</p> <p>To find out more about Flux OCI support please see the Flux OCI docs.</p>"},{"location":"install/","title":"Installation Guide","text":"<p>Timoni is available as a binary executable for Linux, macOS and Windows. The AMD64 and ARM64 binaries can be downloaded from GitHub releases.</p> Install with brewarkadescoopnixyayzypperprotofrom source <p>Install the latest release on macOS or Linux with:</p> <pre><code>brew install stefanprodan/tap/timoni\n</code></pre> <p>Note that the Homebrew formula will setup shell autocompletion for Bash, Fish and Zsh.</p> <p>Install the latest release on Windows, macOS or Linux with:</p> <pre><code>arkade get timoni\n</code></pre> <p>Note that the Arkade version must be 0.9.11 or newer.</p> <p>Install the latest release on Windows with:</p> <pre><code>scoop install timoni\n</code></pre> <p>View the available versions using scoop.sh. The <code>cue</code> dependency will also be installed if necessary.</p> <p>Install the latest release with nix-env:</p> <pre><code>nix-env -i timoni\n</code></pre> <p>Note that the Nix package will setup shell autocompletion for Bash, Fish and Zsh.</p> <p>Install the latest release with yay (or another AUR helper) for Arch Linux:</p> <pre><code>yay -S timoni\n</code></pre> <p>If you prefer to use the upstream binaries:</p> <pre><code>yay -S timoni-bin\n</code></pre> <p>Install the latest release with zypper for openSUSE:</p> <pre><code>zypper install timoni\n</code></pre> <p>To setup shell autocompletion:</p> <pre><code>zypper install timoni-bash-completion\nzypper install timoni-fish-completion\nzypper install timoni-zsh-completion\n</code></pre> <p>Manage multiple versions with proto for all supported systems:</p> <pre><code># .prototools file\n\ntimoni = \"0.19.0\"\n\n[plugins]\ntimoni = \"source:https://raw.githubusercontent.com/stefanprodan/timoni/main/proto-plugin.toml\"\n</code></pre> <p>Using Go &gt;= 1.21:</p> <pre><code>go install github.com/stefanprodan/timoni/cmd/timoni@latest\n</code></pre>"},{"location":"install/#shell-autocompletion","title":"Shell autocompletion","text":"<p>Configure your shell to load timoni completions:</p> BashFishPowershellZsh <p>To load completion run:</p> <pre><code>. &lt;(timoni completion bash)\n</code></pre> <p>To configure your bash shell to load completions for each session add to your bashrc:</p> <pre><code># ~/.bashrc or ~/.bash_profile\ncommand -v timoni &gt;/dev/null &amp;&amp; . &lt;(timoni completion bash)\n</code></pre> <p>If you have an alias for timoni, you can extend shell completion to work with that alias:</p> <pre><code># ~/.bashrc or ~/.bash_profile\nalias tm=timoni\ncomplete -F __start_timoni tm\n</code></pre> <p>To configure your fish shell to load completions for each session write this script to your completions dir:</p> <pre><code>timoni completion fish &gt; ~/.config/fish/completions/timoni.fish\n</code></pre> <p>To load completion run:</p> <pre><code>. &lt;(timoni completion powershell)\n</code></pre> <p>To configure your powershell shell to load completions for each session add to your powershell profile:</p> <p>Windows:</p> <p><pre><code>cd \"$env:USERPROFILE\\Documents\\WindowsPowerShell\\Modules\"\ntimoni completion &gt;&gt; timoni-completion.ps1\n</code></pre> Linux:</p> <pre><code>cd \"${XDG_CONFIG_HOME:-\"$HOME/.config/\"}/powershell/modules\"\ntimoni completion &gt;&gt; timoni-completions.ps1\n</code></pre> <p>To load completion run:</p> <pre><code>. &lt;(timoni completion zsh) &amp;&amp; compdef _timoni timoni\n</code></pre> <p>To configure your zsh shell to load completions for each session add to your zshrc:</p> <pre><code># ~/.zshrc or ~/.profile\ncommand -v timoni &gt;/dev/null &amp;&amp; . &lt;(timoni completion zsh) &amp;&amp; compdef _timoni timoni\n</code></pre> <p>or write a cached file in one of the completion directories in your ${fpath}:</p> <pre><code>echo \"${fpath// /\\n}\" | grep -i completion\ntimoni completion zsh &gt; _timoni\n\nmv _timoni ~/.oh-my-zsh/completions  # oh-my-zsh\nmv _timoni ~/.zprezto/modules/completion/external/src/  # zprezto\n</code></pre>"},{"location":"install/#local-cache","title":"Local cache","text":"<p>Timoni maintains a local cache of modules pulled from remote container registries. Cashing is meant to reduce network traffic for sequential pull operations and speeds up applying bundles which refer to modules with identical layers.</p> <p>The default cache location is <code>$HOME/.timoni/cache</code> and can be changed with either the <code>--cache-dir</code> global flag or <code>TIMONI_CACHE_DIR</code> environment variable. The global flag takes precedence over the environment variable.</p> <p>If the home directory is not writable, caching can be disabled by setting the <code>TIMONI_CACHING=false</code> environment variable.</p>"},{"location":"install/#slsa-provenance-sboms","title":"SLSA Provenance &amp; SBOMs","text":"<p>The build, release and provenance portions of Timoni's supply chain meet the SLSA Build Level 3 requirements.</p> <p>The release artifacts are produced on GitHub-hosted runners using GoReleaser and the provenance generation is handled by the official SLSA GitHub Generator.</p> <p>To verify a release artifact such as the Timoni binary tarball, you can use the slsa-verifier tool:</p> <pre><code>TIMONI_VER=0.10.0 &amp;&amp; \\\ngh release download v${TIMONI_VER} -R=stefanprodan/timoni -p=\"*\" &amp;&amp; \\\nslsa-verifier verify-artifact \\\n--provenance-path timoni_${TIMONI_VER}_provenance.intoto.jsonl \\\n--source-uri github.com/stefanprodan/timoni  \\\n--source-tag v${TIMONI_VER} \\\ntimoni_${TIMONI_VER}_darwin_arm64.tar.gz\n</code></pre> <p>Each release comes with a Software Bill of Materials (SBOM) in SPDX format. The SBOMs are generated on GitHub-hosted runners using GoReleaser and Syft.</p> <p>To scan a release for vulnerabilities, you can use Grype:</p> <pre><code>TIMONI_VER=0.10.0 &amp;&amp; \\\ngh release download v${TIMONI_VER} -R=stefanprodan/timoni -p=\"*sbom.spdx.json\" &amp;&amp; \\\ngrype sbom:./timoni_${TIMONI_VER}_sbom.spdx.json\n</code></pre>"},{"location":"module/","title":"Module Specification","text":"<p>A Timoni module describes how an application can be customised and deployed on Kubernetes, using the CUE configuration language.</p> <p>A module is composed of a set of Kubernetes objects and a well-defined configuration schema. Besides the Kubernetes templates and config schema, a module can specify how the lifecycle of the application should be managed, how the application should be tested.</p> <p>The Timoni modules are packaged as Open Container Initiative (OCI) artifacts and distributed through OCI registries. Modules are semantically versioned and can be referenced by their OCI tag or digest. A module version can be cryptographically signed when pushed to an OCI registry.</p> <p>To facilitate the development, testing, and publishing of modules, the Timoni CLI provides familiar commands tailored for these purposes.</p>"},{"location":"module/#module-structure","title":"Module Structure","text":"<p>The Timoni module file structure consists of a set of directories and CUE files organised into a CUE module.</p> <p>Example of a module's root directory:</p> <pre><code>\u251c\u2500\u2500 cue.mod\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 gen # Kubernetes APIs and CRDs schemas\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 pkg # Timoni APIs schemas\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 module.cue # Module metadata\n\u251c\u2500\u2500 templates\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config.cue # Config schema and default values\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 deployment.cue # Kubernetes Deployment template\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 service.cue # Kubernetes Service template\n\u251c\u2500\u2500 timoni.cue # Timoni entry point\n\u251c\u2500\u2500 timoni.ignore # Timoni ignore rules\n\u251c\u2500\u2500 values.cue # Timoni values placeholder \n\u251c\u2500\u2500 LICENSE # Module license\n\u2514\u2500\u2500 README.md # Module documentation\n</code></pre> <p>Timoni streamlines the creation of new modules through a blueprint-based approach. In addition to utilizing official blueprints, users can develop and employ custom blueprints for generating modules. Timoni further assists in vendoring and keeping Kubernetes APIs and CRDs schemas up-to-date.</p>"},{"location":"module/#module-artifacts","title":"Module Artifacts","text":"<p>A module is packaged as an OCI artifact that contains the contents of the module directory compressed as a gzipped tarball. To optimize the registry storage and to minimize the bandwidth usage, the vendored CUE definitions are stored in a separate artifact layer and  cached locally.</p> <p>The module version is reflected in the artifact tag, and its metadata is stored in the artifact annotations. By default, the module metadata includes the standard <code>org.opencontainers.image</code> annotations and can be extended with custom annotations. The metadata contains information about the module's source code repository and revision, the module's author, license and documentation.</p> <p>Example of a module's OCI manifest:</p> <pre><code>{\n  \"schemaVersion\": 2,\n  \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\",\n  \"config\": {\n    \"mediaType\": \"application/vnd.timoni.config.v1+json\",\n    \"size\": 342,\n    \"digest\": \"sha256:62b6006cf2a56d7cfc8287164b25e47d9bc17b282aeb0701535897960ee13cbf\"\n  },\n  \"layers\": [\n    {\n      \"mediaType\": \"application/vnd.timoni.content.v1.tar+gzip\",\n      \"size\": 121873,\n      \"digest\": \"sha256:fff54591c495da1b19c647da5946c2e93c309e1389b3ac1a17ed293f2bb539fc\",\n      \"annotations\": {\n        \"sh.timoni.content.type\": \"module/vendor\"\n      }\n    },\n    {\n      \"mediaType\": \"application/vnd.timoni.content.v1.tar+gzip\",\n      \"size\": 7837,\n      \"digest\": \"sha256:e6af46874ac539bb63ac6ccf269bbc520c1e6ce5bc7180934cfa17b8cfc5a1b1\",\n      \"annotations\": {\n        \"sh.timoni.content.type\": \"module\"\n      }\n    }\n  ],\n  \"annotations\": {\n    \"org.opencontainers.image.created\": \"2023-12-30T22:19:40Z\",\n    \"org.opencontainers.image.description\": \"Get started blueprint for timoni.sh modules.\",\n    \"org.opencontainers.image.documentation\": \"https://timoni.sh\",\n    \"org.opencontainers.image.licenses\": \"Apache-2.0\",\n    \"org.opencontainers.image.revision\": \"7a0566468fa4d49e3be269ad16f447c06e47de63\",\n    \"org.opencontainers.image.source\": \"https://github.com/stefanprodan/timoni\",\n    \"org.opencontainers.image.version\": \"0.19.0-rc.1\"\n  }\n}\n</code></pre>"},{"location":"module/#module-instance","title":"Module Instance","text":"<p>A Timoni instance represent a module instantiation on a Kubernetes cluster. The instance holds the inventory of the Kubernetes objects deployed on the cluster, the OCI reference of the module, and the user-supplied configuration values.</p> <p>In the cluster, the instance is stored as a Kubernetes Secret of type <code>timoni.sh/instance</code>. The secret's name contains the instance name in the format <code>timoni.&lt;instance name&gt;</code>, and the secret's namespace is the instance namespace.</p> <p>The role of the instance Kubernetes Secret is to keep track of the managed objects and to help Timoni's garbage collector to delete the objects when the instance is uninstalled.</p> <p>Timoni offers a set of commands for inspecting the instance state:</p> <ul> <li><code>timoni inspect module</code> - displays the module URL, digest, and version</li> <li><code>timoni inspect values</code> - displays the instance config values</li> <li><code>timoni inspect resources</code> - displays the Kubernetes objects managed by the instance</li> </ul>"},{"location":"module/#module-development","title":"Module Development","text":"<p>For an overview of CUE and the reasons why we chose it as the configuration language for Timoni, please see the CUE introduction.</p> <p>To get familiar with the CUE syntax, please see the CUE guide. This guide will walk you through the core features of CUE and how to use them to generate Kubernetes objects.</p> <p>To get started with Timoni module development, please see the following guides:</p> <ul> <li>Module initialization</li> <li>Add Kubernetes custom resources</li> <li>Cluster version constraints</li> <li>Control the Apply Behavior</li> <li>Run tests with Kubernetes Jobs</li> </ul>"},{"location":"module/#module-distribution","title":"Module Distribution","text":"<p>Timoni modules are distributed as OCI artifacts, for more information please see:</p> <ul> <li>Module OCI artifact format</li> <li>Module versioning</li> <li>Publishing module versions</li> <li>Module signing and verification</li> <li>Module distribution with GitHub Actions</li> </ul>"},{"location":"quickstart/","title":"Quickstart Guide","text":"<p>This guide shows you the basics of Timoni. You'll deploy a demo application on Kubernetes using a Timoni module published in a container registry.</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>To follow this guide you'll need:</p> <ul> <li>A Kubernetes cluster</li> <li>Timoni installed on a system with writable <code>/tmp</code></li> </ul> <p>Install Timoni with:</p> <pre><code>brew install stefanprodan/tap/timoni\n</code></pre> <p>For other methods, see the installation guide.</p>"},{"location":"quickstart/#install-a-module","title":"Install a module","text":"<p>To install a Timoni module on a Kubernetes cluster, you have to specify the container registry address and the version of a module.</p> <p>Modules and Instances</p> <p>If you are familiar with Helm, a Timoni module is the equivalent of a chart, and a Timoni instance is the equivalent of a Helm release. To learn more about modules and instances, please see the concepts doc.</p> <p>For example, to install the latest stable version of podinfo in a new namespace:</p> commandoutput <pre><code>timoni -n test apply podinfo oci://ghcr.io/stefanprodan/modules/podinfo\n</code></pre> <pre><code>pulling oci://ghcr.io/stefanprodan/modules/podinfo:latest\nusing module timoni.sh/podinfo version 6.5.4\ninstalling podinfo in namespace test\nNamespace/test created\nServiceAccount/test/podinfo created\nService/test/podinfo created\nDeployment/test/podinfo created\nwaiting for 3 resource(s) to become ready...\nall resources are ready\n</code></pre> <p>The apply command pulls the module from the container registry, creates the Kubernetes resources in the specified namespace, and waits for all resources to become ready.</p> <p>To learn more about all the available apply options, use <code>timoni apply --help</code>.</p>"},{"location":"quickstart/#list-and-inspect-instances","title":"List and inspect instances","text":"<p>You can list all instances in a cluster with:</p> commandoutput <pre><code>timoni list -A\n</code></pre> <pre><code>NAME    NAMESPACE   MODULE                                      VERSION LAST APPLIED            BUNDLE \npodinfo test        oci://ghcr.io/stefanprodan/modules/podinfo  6.5.4   2024-01-20T19:51:17Z    - \n</code></pre> <p>To see the status of the Kubernetes resources managed by an instance:</p> commandoutput <pre><code>timoni -n test status podinfo\n</code></pre> <pre><code>last applied 2024-01-20T19:51:17Z\nmodule oci://ghcr.io/stefanprodan/modules/podinfo:6.5.4\ndigest sha256:1dba385f9d56f9a79e5b87344bbec1502bd11f056df51834e18d3e054de39365\ncontainer image ghcr.io/curl/curl-container/curl-multi:master\ncontainer image ghcr.io/stefanprodan/podinfo:6.5.4\nServiceAccount/test/podinfo Current - Resource is current\nService/test/podinfo Current - Service is ready\nDeployment/test/podinfo Current - Deployment is available. Replicas: 1\n</code></pre> <p>To get more information on an instance, you can use the <code>timoni inspect</code> sub-commands.</p> <p>For example, to list the module URL, version and OCI digest of the podinfo instance:</p> commandoutput <pre><code>timoni -n test inspect module podinfo\n</code></pre> <pre><code>digest: sha256:1dba385f9d56f9a79e5b87344bbec1502bd11f056df51834e18d3e054de39365\nname: timoni.sh/podinfo\nrepository: oci://ghcr.io/stefanprodan/modules/podinfo\nversion: 6.5.4\n</code></pre> <p>To learn more about the available commands, use <code>timoni inspect --help</code>.</p>"},{"location":"quickstart/#configure-a-module-instance","title":"Configure a module instance","text":"<p>To customise an instance, you can supply the configuration using values files.</p> <p>For example, to set the QoS class to guaranteed, create a <code>qos-values.cue</code> file that sets the resources limits equal to the requests:</p> <pre><code>values: {\n    resources: requests: {\n        cpu:    \"100m\"\n        memory: \"128Mi\"\n    }\n    resources: limits: resources.requests\n}\n</code></pre> <p>Apply the config to the podinfo module to perform an upgrade:</p> commandoutput <pre><code>timoni -n test apply podinfo oci://ghcr.io/stefanprodan/modules/podinfo \\\n  --values qos-values.cue\n</code></pre> <pre><code>pulling oci://ghcr.io/stefanprodan/modules/podinfo:latest\nusing module timoni.sh/podinfo version 6.5.4\nupgrading podinfo in namespace test\nServiceAccount/test/podinfo unchanged\nService/test/podinfo unchanged\nDeployment/test/podinfo configured\nresources are ready\n</code></pre> <p>Before running an upgrade, you can review the changes that will be made on the cluster with <code>timoni apply --dry-run --diff</code>.</p>"},{"location":"quickstart/#uninstall-a-module-instance","title":"Uninstall a module instance","text":"<p>To uninstall an instance and delete all the managed Kubernetes resources:</p> commandoutput <pre><code>timoni -n test delete podinfo\n</code></pre> <pre><code>deleting 3 resource(s)...\nDeployment/test/podinfo deleted\nService/test/podinfo deleted\nServiceAccount/test/podinfo deleted\nall resources have been deleted\n</code></pre> <p>By default, the delete command will wait for all the resources to be removed. To skip waiting, use the <code>--wait=false</code> flag.</p>"},{"location":"quickstart/#bundling-instances","title":"Bundling instances","text":"<p>For deploying complex applications to production, it is recommended to use Timoni Bundles.</p> <p>A Timoni Bundle is a CUE file for defining a group of instances together with their values and module references.</p> <p>The following is an example of a Bundle that defines a Redis master-replica cluster and a podinfo instance connected to the Redis instance.</p> <pre><code>bundle: {\n    apiVersion: \"v1alpha1\"\n    name:       \"podinfo\"\n    instances: {\n        redis: {\n            module: {\n                url:     \"oci://ghcr.io/stefanprodan/modules/redis\"\n                version: \"7.2.4\"\n            }\n            namespace: \"podinfo\"\n            values: maxmemory: 256\n        }\n        podinfo: {\n            module: url:     \"oci://ghcr.io/stefanprodan/modules/podinfo\"\n            module: version: \"6.5.4\"\n            namespace: \"podinfo\"\n            values: caching: {\n                enabled:  true\n                redisURL: \"tcp://redis:6379\"\n            }\n        }\n    }\n}\n</code></pre> <p>To apply the above bundle on a cluster, save the file as <code>podinfo.bundle.cue</code> and run:</p> <pre><code>timoni bundle apply -f podinfo.bundle.cue\n</code></pre> <p>To list all the instances managed by a bundle:</p> <pre><code>timoni list -A --bundle podinfo\n</code></pre> <p>To delete all the instances defined in a bundle:</p> <pre><code>timoni bundle delete -f podinfo.bundle.cue\n</code></pre> <p>To learn more about bundles, please see the Bundle API and the Bundle distribution documentation.</p>"},{"location":"cmd/timoni/","title":"Timoni","text":""},{"location":"cmd/timoni/#timoni","title":"timoni","text":"<p>A package manager for Kubernetes powered by CUE.</p>"},{"location":"cmd/timoni/#options","title":"Options","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n  -h, --help                                help for timoni\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni apply    - Install or upgrade a module instance</li> <li>timoni artifact  - Commands for managing Open Container Initiative (OCI) artifacts</li> <li>timoni build    - Build an instance from a module and print the resulting Kubernetes resources</li> <li>timoni bundle  - Commands for managing bundles</li> <li>timoni completion  - Generates completion scripts for various shells</li> <li>timoni delete  - Uninstall a module instance from the cluster</li> <li>timoni inspect    - Commands for getting information about installed instances</li> <li>timoni list  - Prints a table of instances and their module version</li> <li>timoni mod    - Commands for managing modules</li> <li>timoni registry  - Commands for managing the authentication to container registries</li> <li>timoni runtime    - Commands for managing runtimes</li> <li>timoni status  - Displays the current status of Kubernetes resources managed by an instance</li> <li>timoni version    - Print the client and API version information</li> </ul>"},{"location":"cmd/timoni_apply/","title":"Timoni apply","text":""},{"location":"cmd/timoni_apply/#timoni-apply","title":"timoni apply","text":"<p>Install or upgrade a module instance</p>"},{"location":"cmd/timoni_apply/#synopsis","title":"Synopsis","text":"<p>The apply command installs or upgrades a module instance on the Kubernetes cluster.</p> <p>The apply command performs the following steps:</p> <ul> <li>Pulls the module version from the specified container registry.</li> <li>If the registry is private, uses the credentials found in '~/.docker/config.json'.</li> <li>If the registry credentials are specified with '--creds', these take priority over the docker ones.</li> <li>Creates the specified '--namespace' if it doesn't exist.</li> <li>Merges all the values supplied with '--values' on top of the default values found in the module.</li> <li>Builds the module by passing the instance name, namespace and values.</li> <li>Labels the resulting Kubernetes resources with the instance name and namespace.</li> <li>Applies the Kubernetes resources on the cluster.</li> <li>Creates or updates the instance inventory with the last applied resources IDs (stored in a secret named timoni.). <li>Recreates the resources annotated with 'action.timoni.sh/force: \"enabled\"' if they contain changes to immutable fields.</li> <li>Waits for the applied resources to become ready.</li> <li>Deletes the resources which were previously applied but are missing from the current instance.</li> <li>Skips the resources annotated with 'action.timoni.sh/prune: \"disabled\"' from deletion.</li> <li>Waits for the deleted resources to be finalised.</li> <pre><code>timoni apply [INSTANCE NAME] [MODULE URL] [flags]\n</code></pre>"},{"location":"cmd/timoni_apply/#examples","title":"Examples","text":"<pre><code>  # Install a module instance and create the namespace if it doesn't exists\n  timoni apply -n apps app oci://docker.io/org/module -v 1.0.0\n\n  # Do a dry-run upgrade and print the diff\n  timoni apply -n apps app oci://docker.io/org/module -v 1.0.0 \\\n  --values ./values-1.cue \\\n  --dry-run --diff\n\n  # Install or upgrade an instance with custom values by merging them in the specified order\n  timoni apply -n apps app oci://docker.io/org/module -v 1.0.0 \\\n  --values ./values-1.cue \\\n  --values ./values-2.cue\n\n  # Upgrade an instance and recreate immutable Kubernetes resources such as Jobs\n  timoni apply -n apps app oci://docker.io/org/module -v 2.0.0 \\\n  --values ./values-1.cue \\\n  --force\n\n  # Install or upgrade an instance with custom values from stdin\n  echo \"values: replicas: 2\" | timoni apply -n apps app oci://docker.io/org/module --values -\n\n  # Install or upgrade an instance with values in YAML and JSON format\n  timoni apply -n apps app oci://docker.io/org/module \\\n  --values ./values-1.yaml \\\n  --values ./values-2.json\n</code></pre>"},{"location":"cmd/timoni_apply/#options","title":"Options","text":"<pre><code>      --creds creds           The credentials for the container registry in the format '&lt;username&gt;[:&lt;password&gt;]'.\n      --diff                  Perform a server-side apply dry run and prints the diff.\n  -d, --digest digest         The digest of the module e.g. sha256:3f29e1b2b05f8371595dc761fed8e8b37544b38d56dfce81a551b46c82f2f56b.\n      --dry-run               Perform a server-side apply dry run.\n      --force                 Recreate immutable Kubernetes resources.\n  -h, --help                  help for apply\n      --overwrite-ownership   Overwrite instance ownership, if the instance is owned by a Bundle.\n  -p, --package package       The name of the module's package used for building the templates. (default main)\n  -f, --values strings        The local path to values files (cue, yaml or json format).\n  -v, --version version       The version of the module e.g. '1.0.0' or '1.0.0-rc.1'.\n      --wait                  Wait for the applied Kubernetes objects to become ready. (default true)\n</code></pre>"},{"location":"cmd/timoni_apply/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_apply/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni    - A package manager for Kubernetes powered by CUE.</li> </ul>"},{"location":"cmd/timoni_artifact/","title":"Timoni artifact","text":""},{"location":"cmd/timoni_artifact/#timoni-artifact","title":"timoni artifact","text":"<p>Commands for managing Open Container Initiative (OCI) artifacts</p>"},{"location":"cmd/timoni_artifact/#options","title":"Options","text":"<pre><code>  -h, --help   help for artifact\n</code></pre>"},{"location":"cmd/timoni_artifact/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_artifact/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni    - A package manager for Kubernetes powered by CUE.</li> <li>timoni artifact list    - List the tags of an artifact</li> <li>timoni artifact pull    - Pull an artifact from a container registry</li> <li>timoni artifact push    - Push a directory contents to a container registry</li> <li>timoni artifact tag  - Tag an OCI artifact in the upstream registry</li> </ul>"},{"location":"cmd/timoni_artifact_list/","title":"Timoni artifact list","text":""},{"location":"cmd/timoni_artifact_list/#timoni-artifact-list","title":"timoni artifact list","text":"<p>List the tags of an artifact</p>"},{"location":"cmd/timoni_artifact_list/#synopsis","title":"Synopsis","text":"<p>The list command prints a table with the artifact tags and their digests.</p> <pre><code>timoni artifact list [ARTIFACT URL] [flags]\n</code></pre>"},{"location":"cmd/timoni_artifact_list/#examples","title":"Examples","text":"<pre><code>  # Print the tags and digests of an artifact\n  timoni artifact ls oci://docker.io/org/app \n\n  # Print the tags without digests\n  timoni artifact list oci://ghcr.io/org/bundles/app --with-digest=false\n\n  # Print the tags and digests of an artifact stored in a private repository\n  echo $DOCKER_TOKEN | timoni registry login docker.io -u timoni --password-stdin\n  timoni artifact list oci://docker.io/org/app\n</code></pre>"},{"location":"cmd/timoni_artifact_list/#options","title":"Options","text":"<pre><code>      --creds creds   The credentials for the container registry in the format '&lt;username&gt;[:&lt;password&gt;]'.\n  -h, --help          help for list\n      --with-digest   Resolve the digest of each version. (default true)\n</code></pre>"},{"location":"cmd/timoni_artifact_list/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_artifact_list/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni artifact  - Commands for managing Open Container Initiative (OCI) artifacts</li> </ul>"},{"location":"cmd/timoni_artifact_pull/","title":"Timoni artifact pull","text":""},{"location":"cmd/timoni_artifact_pull/#timoni-artifact-pull","title":"timoni artifact pull","text":"<p>Pull an artifact from a container registry</p>"},{"location":"cmd/timoni_artifact_pull/#synopsis","title":"Synopsis","text":"<p>The pull command downloads an artifact with the application/vnd.timoni media type from a container registry and extract the selected layers to the specified directory.</p> <pre><code>timoni artifact pull [ARTIFACT URL] [flags]\n</code></pre>"},{"location":"cmd/timoni_artifact_pull/#examples","title":"Examples","text":"<pre><code>  # Pull latest artifact and extract its contents to the current directory\n  timoni artifact pull oci://docker.io/org/app:latest\n\n  # Pull an artifact by tag from a private GHCR repository\n  echo $GITHUB_TOKEN | timoni registry login ghcr.io -u timoni --password-stdin\n  timoni artifact pull oci://ghcr.io/org/schemas/app:1.0.0 \\\n    --output=./modules/my-app/cue.mod/pkg\n\n  # Verify the Cosign signature and pull (the cosign binary must be present in PATH)\n  timoni artifact pull oci://docker.io/org/app:latest \\\n    --verify=cosign \\\n    --cosign-key=/path/to/cosign.pub\n\n  # Verify the Cosign keyless signature and pull (the cosign binary must be present in PATH)\n  timoni artifact pull oci://ghcr.io/org/schemas/app:1.0.0 \\\n    --verify=cosign \\\n    --certificate-identity-regexp=\"^https://github.com/org/.*$\" \\\n    --certificate-oidc-issuer=https://token.actions.githubusercontent.com \\\n    --output=./modules/my-app/cue.mod/pkg\n</code></pre>"},{"location":"cmd/timoni_artifact_pull/#options","title":"Options","text":"<pre><code>      --certificate-identity string             The identity expected in a valid Fulcio certificate for verifying the Cosign signature.\n                                                Valid values include email address, DNS names, IP addresses, and URIs.\n                                                Either --certificate-identity or --certificate-identity-regexp must be set for keyless flows.\n      --certificate-identity-regexp string      A regular expression alternative to --certificate-identity for verifying the Cosign signature.\n                                                Accepts the Go regular expression syntax described at https://golang.org/s/re2syntax.\n                                                Either --certificate-identity or --certificate-identity-regexp must be set for keyless flows.\n      --certificate-oidc-issuer string          The OIDC issuer expected in a valid Fulcio certificate for verifying the Cosign signature,\n                                                e.g. https://token.actions.githubusercontent.com or https://oauth2.sigstore.dev/auth.\n                                                Either --certificate-oidc-issuer or --certificate-oidc-issuer-regexp must be set for keyless flows.\n      --certificate-oidc-issuer-regexp string   A regular expression alternative to --certificate-oidc-issuer for verifying the Cosign signature.\n                                                Accepts the Go regular expression syntax described at https://golang.org/s/re2syntax.\n                                                Either --certificate-oidc-issuer or --certificate-oidc-issuer-regexp must be set for keyless flows.\n      --content-type string                     Fetch the contents of the layers matching this type.\n      --cosign-key string                       The Cosign public key for verifying the artifact.\n      --creds creds                             The credentials for the container registry in the format '&lt;username&gt;[:&lt;password&gt;]'.\n  -h, --help                                    help for pull\n  -o, --output string                           The directory path where the artifact content should be extracted. (default \".\")\n      --verify string                           Verifies the signed artifact with the specified provider.\n</code></pre>"},{"location":"cmd/timoni_artifact_pull/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_artifact_pull/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni artifact  - Commands for managing Open Container Initiative (OCI) artifacts</li> </ul>"},{"location":"cmd/timoni_artifact_push/","title":"Timoni artifact push","text":""},{"location":"cmd/timoni_artifact_push/#timoni-artifact-push","title":"timoni artifact push","text":"<p>Push a directory contents to a container registry</p>"},{"location":"cmd/timoni_artifact_push/#synopsis","title":"Synopsis","text":"<p>The push command packages a directory contents as an OCI artifact and pushes it to the container registry. If the directory contains a timoni.ignore file, the ignore rules will be used to exclude files from the artifact.</p> <pre><code>timoni artifact push [REPOSITORY URL] [flags]\n</code></pre>"},{"location":"cmd/timoni_artifact_push/#examples","title":"Examples","text":"<pre><code>  # Push the current dir contents to Docker Hub using the credentials from '~/.docker/config.json'\n  echo $DOCKER_PAT | docker login --username timoni --password-stdin\n  timoni artifact push oci://docker.io/org/app -t latest -f .\n\n # Push a dir contents to GitHub Container Registry using a GitHub token\n  timoni artifact push oci://ghcr.io/org/schemas/app -f ./path/to/bundles \\\n    --creds=timoni:$GITHUB_TOKEN \\\n    --tag=\"$(git rev-parse --short HEAD)\" \\\n    --tag=latest \\\n    --annotation=\"org.opencontainers.image.source=$(git config --get remote.origin.url)\" \\\n    --annotation=\"org.opencontainers.image.revision=$(git rev-parse HEAD)' \\\n    --content-type=\"timoni.sh/bundles\"\n\n  # Push and sign with Cosign (the cosign binary must be present in PATH)\n  echo $GITHUB_TOKEN | timoni registry login ghcr.io -u timoni --password-stdin\n  export COSIGN_PASSWORD=password\n  timoni artifact push oci://ghcr.io/org/schemas/app \\\n    -f=/path/to/schemas \\\n    --tag=1.0.0 \\\n    --sign=cosign \\\n    --cosign-key=/path/to/cosign.key\n</code></pre>"},{"location":"cmd/timoni_artifact_push/#options","title":"Options","text":"<pre><code>  -a, --annotation stringArray   Annotation in the format '&lt;key&gt;=&lt;value&gt;'.\n      --content-type string      The content type of this artifact. (default \"generic\")\n      --cosign-key string        The Cosign private key for signing the module.\n      --creds creds              The credentials for the container registry in the format '&lt;username&gt;[:&lt;password&gt;]'.\n  -f, --filepath string          Path to local file or directory. (default \".\")\n  -h, --help                     help for push\n      --sign string              Signs the module with the specified provider.\n  -t, --tag stringArray          Tag of the artifact.\n</code></pre>"},{"location":"cmd/timoni_artifact_push/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_artifact_push/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni artifact  - Commands for managing Open Container Initiative (OCI) artifacts</li> </ul>"},{"location":"cmd/timoni_artifact_tag/","title":"Timoni artifact tag","text":""},{"location":"cmd/timoni_artifact_tag/#timoni-artifact-tag","title":"timoni artifact tag","text":"<p>Tag an OCI artifact in the upstream registry</p>"},{"location":"cmd/timoni_artifact_tag/#synopsis","title":"Synopsis","text":"<p>The tag command allows adding tags to an existing artifact.</p> <pre><code>timoni artifact tag [ARTIFACT URL] [flags]\n</code></pre>"},{"location":"cmd/timoni_artifact_tag/#examples","title":"Examples","text":"<pre><code>  # Tag an existing artifact with a new tags\n  echo $DOCKER_PAT | docker login --username timoni --password-stdin\n  timoni artifact tag oci://docker.io/org/app:1.0.0 -t 1.0 -t latest\n</code></pre>"},{"location":"cmd/timoni_artifact_tag/#options","title":"Options","text":"<pre><code>      --creds creds       The credentials for the container registry in the format '&lt;username&gt;[:&lt;password&gt;]'.\n  -h, --help              help for tag\n  -t, --tag stringArray   Tag of the artifact.\n</code></pre>"},{"location":"cmd/timoni_artifact_tag/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_artifact_tag/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni artifact  - Commands for managing Open Container Initiative (OCI) artifacts</li> </ul>"},{"location":"cmd/timoni_build/","title":"Timoni build","text":""},{"location":"cmd/timoni_build/#timoni-build","title":"timoni build","text":"<p>Build an instance from a module and print the resulting Kubernetes resources</p> <pre><code>timoni build [INSTANCE NAME] [MODULE URL] [flags]\n</code></pre>"},{"location":"cmd/timoni_build/#examples","title":"Examples","text":"<pre><code>  # Build an instance from a local module\n  timoni build app ./path/to/module --output yaml\n\n  # Build an instance with custom values by merging them in the specified order\n  timoni build app ./path/to/module \\\n  --values ./values-1.cue \\\n  --values ./values-2.cue\n</code></pre>"},{"location":"cmd/timoni_build/#options","title":"Options","text":"<pre><code>      --creds creds       The credentials for the container registry in the format '&lt;username&gt;[:&lt;password&gt;]'.\n  -d, --digest digest     The digest of the module e.g. sha256:3f29e1b2b05f8371595dc761fed8e8b37544b38d56dfce81a551b46c82f2f56b.\n  -h, --help              help for build\n  -o, --output string     The format in which the Kubernetes objects should be printed, can be 'yaml' or 'json'. (default \"yaml\")\n  -p, --package package   The name of the module's package used for building the templates. (default main)\n  -f, --values strings    The local path to values files (cue, yaml or json format).\n  -v, --version version   The version of the module e.g. '1.0.0' or '1.0.0-rc.1'.\n</code></pre>"},{"location":"cmd/timoni_build/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_build/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni    - A package manager for Kubernetes powered by CUE.</li> </ul>"},{"location":"cmd/timoni_bundle/","title":"Timoni bundle","text":""},{"location":"cmd/timoni_bundle/#timoni-bundle","title":"timoni bundle","text":"<p>Commands for managing bundles</p>"},{"location":"cmd/timoni_bundle/#options","title":"Options","text":"<pre><code>  -h, --help                     help for bundle\n  -r, --runtime strings          The local path to runtime.cue files.\n      --runtime-cluster string   Filter runtime cluster by name. (default \"*\")\n      --runtime-from-env         Inject runtime values from the environment.\n      --runtime-group string     Filter runtime clusters by group. (default \"*\")\n</code></pre>"},{"location":"cmd/timoni_bundle/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_bundle/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni    - A package manager for Kubernetes powered by CUE.</li> <li>timoni bundle apply  - Install or upgrade instances from a bundle</li> <li>timoni bundle build  - Build and print the resulting Kubernetes resources for all instances from a Bundle</li> <li>timoni bundle delete    - Delete all instances from a bundle</li> <li>timoni bundle status    - Displays the current status of Kubernetes resources managed by the bundle instances</li> <li>timoni bundle vet  - Validate a bundle definition</li> </ul>"},{"location":"cmd/timoni_bundle_apply/","title":"Timoni bundle apply","text":""},{"location":"cmd/timoni_bundle_apply/#timoni-bundle-apply","title":"timoni bundle apply","text":"<p>Install or upgrade instances from a bundle</p>"},{"location":"cmd/timoni_bundle_apply/#synopsis","title":"Synopsis","text":"<p>The bundle apply command installs or upgrades the instances defined in a bundle.</p> <pre><code>timoni bundle apply [flags]\n</code></pre>"},{"location":"cmd/timoni_bundle_apply/#examples","title":"Examples","text":"<pre><code>  # Install all instances from a bundle\n  timoni bundle apply -f bundle.cue\n\n  # Do a dry-run upgrade and print the diff\n  timoni bundle apply -f bundle.cue \\\n  --dry-run --diff\n\n  # Force apply instances from multiple bundles\n  timoni bundle apply --force \\\n  -f ./bundle.cue \\\n  -f ./bundle_secrets.cue\n\n  # Pass secret values from stdin\n  cat ./bundle_secrets.cue | timoni bundle apply -f ./bundle.cue -f -\n</code></pre>"},{"location":"cmd/timoni_bundle_apply/#options","title":"Options","text":"<pre><code>      --creds creds           The credentials for the container registry in the format '&lt;username&gt;[:&lt;password&gt;]'.\n      --diff                  Perform a server-side apply dry run and prints the diff.\n      --dry-run               Perform a server-side apply dry run.\n  -f, --file strings          The local path to bundle.cue files.\n      --force                 Recreate immutable Kubernetes resources.\n  -h, --help                  help for apply\n      --overwrite-ownership   Overwrite instance ownership, if any instances are owned by other Bundles.\n  -p, --package package       The name of the module's package used for building the templates. (default main)\n      --wait                  Wait for the applied Kubernetes objects to become ready. (default true)\n</code></pre>"},{"location":"cmd/timoni_bundle_apply/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n  -r, --runtime strings                     The local path to runtime.cue files.\n      --runtime-cluster string              Filter runtime cluster by name. (default \"*\")\n      --runtime-from-env                    Inject runtime values from the environment.\n      --runtime-group string                Filter runtime clusters by group. (default \"*\")\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_bundle_apply/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni bundle  - Commands for managing bundles</li> </ul>"},{"location":"cmd/timoni_bundle_build/","title":"Timoni bundle build","text":""},{"location":"cmd/timoni_bundle_build/#timoni-bundle-build","title":"timoni bundle build","text":"<p>Build and print the resulting Kubernetes resources for all instances from a Bundle</p>"},{"location":"cmd/timoni_bundle_build/#synopsis","title":"Synopsis","text":"<p>The bundle build command builds and prints the resulting Kubernetes resources for all instances defined in a Bundle.</p> <pre><code>timoni bundle build [flags]\n</code></pre>"},{"location":"cmd/timoni_bundle_build/#examples","title":"Examples","text":"<pre><code>  # Build all instances from a bundle\n  timoni bundle build -f bundle.cue\n\n  # Pass secret values from stdin\n  cat ./bundle_secrets.cue | timoni bundle build -f ./bundle.cue -f -\n</code></pre>"},{"location":"cmd/timoni_bundle_build/#options","title":"Options","text":"<pre><code>      --creds creds       The credentials for the container registry in the format '&lt;username&gt;[:&lt;password&gt;]'.\n  -f, --file strings      The local path to bundle.cue files.\n  -h, --help              help for build\n  -p, --package package   The name of the module's package used for building the templates. (default main)\n</code></pre>"},{"location":"cmd/timoni_bundle_build/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n  -r, --runtime strings                     The local path to runtime.cue files.\n      --runtime-cluster string              Filter runtime cluster by name. (default \"*\")\n      --runtime-from-env                    Inject runtime values from the environment.\n      --runtime-group string                Filter runtime clusters by group. (default \"*\")\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_bundle_build/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni bundle  - Commands for managing bundles</li> </ul>"},{"location":"cmd/timoni_bundle_delete/","title":"Timoni bundle delete","text":""},{"location":"cmd/timoni_bundle_delete/#timoni-bundle-delete","title":"timoni bundle delete","text":"<p>Delete all instances from a bundle</p>"},{"location":"cmd/timoni_bundle_delete/#synopsis","title":"Synopsis","text":"<p>The bundle delete command uninstalls the instances and deletes all their Kubernetes resources from the cluster.'.</p> <pre><code>timoni bundle delete [flags]\n</code></pre>"},{"location":"cmd/timoni_bundle_delete/#examples","title":"Examples","text":"<pre><code>  # Uninstall all instances in a bundle\n  timoni bundle delete -f bundle.cue\n\n  # Uninstall all instances in a named bundle\n  timoni bundle delete my-app\n\n  # Uninstall all instances without waiting for finalisation\n  timoni bundle delete my-app --wait=false\n\n  # Do a dry-run uninstall and print the changes\n  timoni bundle delete my-app --dry-run\n</code></pre>"},{"location":"cmd/timoni_bundle_delete/#options","title":"Options","text":"<pre><code>      --dry-run       Perform a server-side delete dry run.\n  -f, --file string   The local path to bundle.cue file.\n  -h, --help          help for delete\n      --wait          Wait for the deleted Kubernetes objects to be finalized. (default true)\n</code></pre>"},{"location":"cmd/timoni_bundle_delete/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n  -r, --runtime strings                     The local path to runtime.cue files.\n      --runtime-cluster string              Filter runtime cluster by name. (default \"*\")\n      --runtime-from-env                    Inject runtime values from the environment.\n      --runtime-group string                Filter runtime clusters by group. (default \"*\")\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_bundle_delete/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni bundle  - Commands for managing bundles</li> </ul>"},{"location":"cmd/timoni_bundle_status/","title":"Timoni bundle status","text":""},{"location":"cmd/timoni_bundle_status/#timoni-bundle-status","title":"timoni bundle status","text":"<p>Displays the current status of Kubernetes resources managed by the bundle instances</p> <pre><code>timoni bundle status [BUNDLE NAME] [flags]\n</code></pre>"},{"location":"cmd/timoni_bundle_status/#examples","title":"Examples","text":"<pre><code>  # Show the status of the resources managed by a bundle\n  timoni bundle status -f bundle.cue\n\n  # Show the status using a named bundle\n  timoni bundle status my-app\n</code></pre>"},{"location":"cmd/timoni_bundle_status/#options","title":"Options","text":"<pre><code>  -f, --file string   The local path to bundle.cue file.\n  -h, --help          help for status\n</code></pre>"},{"location":"cmd/timoni_bundle_status/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n  -r, --runtime strings                     The local path to runtime.cue files.\n      --runtime-cluster string              Filter runtime cluster by name. (default \"*\")\n      --runtime-from-env                    Inject runtime values from the environment.\n      --runtime-group string                Filter runtime clusters by group. (default \"*\")\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_bundle_status/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni bundle  - Commands for managing bundles</li> </ul>"},{"location":"cmd/timoni_bundle_vet/","title":"Timoni bundle vet","text":""},{"location":"cmd/timoni_bundle_vet/#timoni-bundle-vet","title":"timoni bundle vet","text":"<p>Validate a bundle definition</p>"},{"location":"cmd/timoni_bundle_vet/#synopsis","title":"Synopsis","text":"<p>The bundle vet command validates that a bundle definition conforms with Timoni's schema and optionally prints the computed value.</p> <pre><code>timoni bundle vet [flags]\n</code></pre>"},{"location":"cmd/timoni_bundle_vet/#examples","title":"Examples","text":"<pre><code>  # Validate a bundle and list its instances\n  timoni bundle vet -f bundle.cue\n\n  # Validate a bundle defined in multiple files and print the computed value\n  timoni bundle vet \\\n  -f ./bundle.cue \\\n  -f ./bundle_secrets.cue \\\n  --print-value\n\n  # Validate a bundle with runtime attributes and print the computed value\n  timoni bundle vet \\\n  -f bundle.cue \\\n  -r runtime.cue \\\n  --print-value\n</code></pre>"},{"location":"cmd/timoni_bundle_vet/#options","title":"Options","text":"<pre><code>  -f, --file strings      The local path to bundle.cue files.\n  -h, --help              help for vet\n  -p, --package package   The name of the module's package used for building the templates. (default main)\n      --print-value       Print the computed value of the bundle.\n</code></pre>"},{"location":"cmd/timoni_bundle_vet/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n  -r, --runtime strings                     The local path to runtime.cue files.\n      --runtime-cluster string              Filter runtime cluster by name. (default \"*\")\n      --runtime-from-env                    Inject runtime values from the environment.\n      --runtime-group string                Filter runtime clusters by group. (default \"*\")\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_bundle_vet/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni bundle  - Commands for managing bundles</li> </ul>"},{"location":"cmd/timoni_completion/","title":"Timoni completion","text":""},{"location":"cmd/timoni_completion/#timoni-completion","title":"timoni completion","text":"<p>Generates completion scripts for various shells</p>"},{"location":"cmd/timoni_completion/#synopsis","title":"Synopsis","text":"<p>The completion sub-command generates completion scripts for various shells</p>"},{"location":"cmd/timoni_completion/#options","title":"Options","text":"<pre><code>  -h, --help   help for completion\n</code></pre>"},{"location":"cmd/timoni_completion/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_completion/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni    - A package manager for Kubernetes powered by CUE.</li> <li>timoni completion bash    - Generates bash completion scripts</li> <li>timoni completion fish    - Generates fish completion scripts</li> <li>timoni completion powershell    - Generates powershell completion scripts</li> <li>timoni completion zsh  - Generates zsh completion scripts</li> </ul>"},{"location":"cmd/timoni_completion_bash/","title":"Timoni completion bash","text":""},{"location":"cmd/timoni_completion_bash/#timoni-completion-bash","title":"timoni completion bash","text":"<p>Generates bash completion scripts</p> <pre><code>timoni completion bash [flags]\n</code></pre>"},{"location":"cmd/timoni_completion_bash/#examples","title":"Examples","text":"<pre><code>To load completion run\n\n. &lt;(timoni completion bash)\n\nTo configure your bash shell to load completions for each session add to your bashrc\n\n# ~/.bashrc or ~/.profile\ncommand -v timoni &gt;/dev/null &amp;&amp; . &lt;(timoni completion bash)\n</code></pre>"},{"location":"cmd/timoni_completion_bash/#options","title":"Options","text":"<pre><code>  -h, --help   help for bash\n</code></pre>"},{"location":"cmd/timoni_completion_bash/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_completion_bash/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni completion  - Generates completion scripts for various shells</li> </ul>"},{"location":"cmd/timoni_completion_fish/","title":"Timoni completion fish","text":""},{"location":"cmd/timoni_completion_fish/#timoni-completion-fish","title":"timoni completion fish","text":"<p>Generates fish completion scripts</p> <pre><code>timoni completion fish [flags]\n</code></pre>"},{"location":"cmd/timoni_completion_fish/#examples","title":"Examples","text":"<pre><code>To configure your fish shell to load completions for each session write this script to your completions dir:\n\ntimoni completion fish &gt; ~/.config/fish/completions/timoni.fish\n\nSee http://fishshell.com/docs/current/index.html#completion-own for more details\n</code></pre>"},{"location":"cmd/timoni_completion_fish/#options","title":"Options","text":"<pre><code>  -h, --help   help for fish\n</code></pre>"},{"location":"cmd/timoni_completion_fish/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_completion_fish/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni completion  - Generates completion scripts for various shells</li> </ul>"},{"location":"cmd/timoni_completion_powershell/","title":"Timoni completion powershell","text":""},{"location":"cmd/timoni_completion_powershell/#timoni-completion-powershell","title":"timoni completion powershell","text":"<p>Generates powershell completion scripts</p> <pre><code>timoni completion powershell [flags]\n</code></pre>"},{"location":"cmd/timoni_completion_powershell/#examples","title":"Examples","text":"<pre><code>To load completion run\n\n. &lt;(timoni completion powershell)\n\nTo configure your powershell shell to load completions for each session add to your powershell profile\n\nWindows:\n\ncd \"$env:USERPROFILE\\Documents\\WindowsPowerShell\\Modules\"\ntimoni completion &gt;&gt; timoni-completion.ps1\n\nLinux:\n\ncd \"${XDG_CONFIG_HOME:-\"$HOME/.config/\"}/powershell/modules\"\ntimoni completion &gt;&gt; timoni-completions.ps1\n</code></pre>"},{"location":"cmd/timoni_completion_powershell/#options","title":"Options","text":"<pre><code>  -h, --help   help for powershell\n</code></pre>"},{"location":"cmd/timoni_completion_powershell/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_completion_powershell/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni completion  - Generates completion scripts for various shells</li> </ul>"},{"location":"cmd/timoni_completion_zsh/","title":"Timoni completion zsh","text":""},{"location":"cmd/timoni_completion_zsh/#timoni-completion-zsh","title":"timoni completion zsh","text":"<p>Generates zsh completion scripts</p> <pre><code>timoni completion zsh [flags]\n</code></pre>"},{"location":"cmd/timoni_completion_zsh/#examples","title":"Examples","text":"<pre><code>To load completion run\n\n. &lt;(timoni completion zsh) &amp;&amp; compdef _timoni timoni\n\nTo configure your zsh shell to load completions for each session add to your zshrc\n\n# ~/.zshrc or ~/.profile\ncommand -v timoni &gt;/dev/null &amp;&amp; . &lt;(timoni completion zsh) &amp;&amp; compdef _timoni timoni\n\nor write a cached file in one of the completion directories in your ${fpath}:\n\necho \"${fpath// /\\n}\" | grep -i completion\ntimoni completion zsh &gt; _timoni\n\nmv _timoni ~/.oh-my-zsh/completions  # oh-my-zsh\nmv _timoni ~/.zprezto/modules/completion/external/src/  # zprezto\n</code></pre>"},{"location":"cmd/timoni_completion_zsh/#options","title":"Options","text":"<pre><code>  -h, --help   help for zsh\n</code></pre>"},{"location":"cmd/timoni_completion_zsh/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_completion_zsh/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni completion  - Generates completion scripts for various shells</li> </ul>"},{"location":"cmd/timoni_delete/","title":"Timoni delete","text":""},{"location":"cmd/timoni_delete/#timoni-delete","title":"timoni delete","text":"<p>Uninstall a module instance from the cluster</p> <pre><code>timoni delete [INSTANCE NAME] [flags]\n</code></pre>"},{"location":"cmd/timoni_delete/#examples","title":"Examples","text":"<pre><code>  # Uninstall the app module from the default namespace\n  timoni -n default delete app\n\n  # Do a dry-run uninstall and print the changes\n  timoni delete --dry-run app\n</code></pre>"},{"location":"cmd/timoni_delete/#options","title":"Options","text":"<pre><code>      --dry-run   Perform a server-side delete dry run.\n  -h, --help      help for delete\n      --wait      Wait for the deleted Kubernetes objects to be finalized. (default true)\n</code></pre>"},{"location":"cmd/timoni_delete/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_delete/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni    - A package manager for Kubernetes powered by CUE.</li> </ul>"},{"location":"cmd/timoni_inspect/","title":"Timoni inspect","text":""},{"location":"cmd/timoni_inspect/#timoni-inspect","title":"timoni inspect","text":"<p>Commands for getting information about installed instances</p>"},{"location":"cmd/timoni_inspect/#options","title":"Options","text":"<pre><code>  -h, --help   help for inspect\n</code></pre>"},{"location":"cmd/timoni_inspect/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_inspect/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni    - A package manager for Kubernetes powered by CUE.</li> <li>timoni inspect module  - Print the module information of an instance</li> <li>timoni inspect resources    - Print the Kubernetes objects managed by an instance</li> <li>timoni inspect values  - Print the values of an instance</li> </ul>"},{"location":"cmd/timoni_inspect_module/","title":"Timoni inspect module","text":""},{"location":"cmd/timoni_inspect_module/#timoni-inspect-module","title":"timoni inspect module","text":"<p>Print the module information of an instance</p> <pre><code>timoni inspect module [INSTANCE NAME] [flags]\n</code></pre>"},{"location":"cmd/timoni_inspect_module/#examples","title":"Examples","text":"<pre><code>  # Print the module info\n  timoni -n default inspect module app\n</code></pre>"},{"location":"cmd/timoni_inspect_module/#options","title":"Options","text":"<pre><code>  -h, --help   help for module\n</code></pre>"},{"location":"cmd/timoni_inspect_module/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_inspect_module/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni inspect    - Commands for getting information about installed instances</li> </ul>"},{"location":"cmd/timoni_inspect_resources/","title":"Timoni inspect resources","text":""},{"location":"cmd/timoni_inspect_resources/#timoni-inspect-resources","title":"timoni inspect resources","text":"<p>Print the Kubernetes objects managed by an instance</p> <pre><code>timoni inspect resources [INSTANCE NAME] [flags]\n</code></pre>"},{"location":"cmd/timoni_inspect_resources/#examples","title":"Examples","text":"<pre><code>  # Print the managed resources\n  timoni -n default inspect resources app\n</code></pre>"},{"location":"cmd/timoni_inspect_resources/#options","title":"Options","text":"<pre><code>  -h, --help   help for resources\n</code></pre>"},{"location":"cmd/timoni_inspect_resources/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_inspect_resources/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni inspect    - Commands for getting information about installed instances</li> </ul>"},{"location":"cmd/timoni_inspect_values/","title":"Timoni inspect values","text":""},{"location":"cmd/timoni_inspect_values/#timoni-inspect-values","title":"timoni inspect values","text":"<p>Print the values of an instance</p> <pre><code>timoni inspect values [INSTANCE NAME] [flags]\n</code></pre>"},{"location":"cmd/timoni_inspect_values/#examples","title":"Examples","text":"<pre><code>  # Print the values\n  timoni inspect values app\n\n  # Export the values of an instance to a CUE file\n  timoni -n default inspect values app &gt; values.cue\n</code></pre>"},{"location":"cmd/timoni_inspect_values/#options","title":"Options","text":"<pre><code>  -h, --help   help for values\n</code></pre>"},{"location":"cmd/timoni_inspect_values/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_inspect_values/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni inspect    - Commands for getting information about installed instances</li> </ul>"},{"location":"cmd/timoni_list/","title":"Timoni list","text":""},{"location":"cmd/timoni_list/#timoni-list","title":"timoni list","text":"<p>Prints a table of instances and their module version</p> <pre><code>timoni list [flags]\n</code></pre>"},{"location":"cmd/timoni_list/#examples","title":"Examples","text":"<pre><code> # List all instances in a namespace\n  timoni list --namespace default\n\n  # List all instances on a cluster\n  timoni ls -A\n\n  # List all instances on a cluster subject to a certain bundle\n  timoni ls -A --bundle podinfo\n</code></pre>"},{"location":"cmd/timoni_list/#options","title":"Options","text":"<pre><code>  -A, --all-namespaces   List the requested object(s) across all namespaces.\n      --bundle string    List the requested object(s) subject to a certain bundle.\n  -h, --help             help for list\n</code></pre>"},{"location":"cmd/timoni_list/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_list/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni    - A package manager for Kubernetes powered by CUE.</li> </ul>"},{"location":"cmd/timoni_mod/","title":"Timoni mod","text":""},{"location":"cmd/timoni_mod/#timoni-mod","title":"timoni mod","text":"<p>Commands for managing modules</p>"},{"location":"cmd/timoni_mod/#options","title":"Options","text":"<pre><code>  -h, --help   help for mod\n</code></pre>"},{"location":"cmd/timoni_mod/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_mod/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni    - A package manager for Kubernetes powered by CUE.</li> <li>timoni mod init  - Create a module along with common files and directories</li> <li>timoni mod list  - List the versions of a module</li> <li>timoni mod pull  - Pull a module version from a container registry</li> <li>timoni mod push  - Push a module to a container registry</li> <li>timoni mod show  - Commands for showing module information</li> <li>timoni mod vendor  - Commands for vendoring CUE schemas</li> <li>timoni mod vet    - Validate a local module</li> </ul>"},{"location":"cmd/timoni_mod_init/","title":"Timoni mod init","text":""},{"location":"cmd/timoni_mod_init/#timoni-mod-init","title":"timoni mod init","text":"<p>Create a module along with common files and directories</p> <pre><code>timoni mod init [MODULE NAME] [PATH] [flags]\n</code></pre>"},{"location":"cmd/timoni_mod_init/#examples","title":"Examples","text":"<pre><code>  # Create a module in the current directory\n  timoni mod init my-app\n\n  # Create a module at the specified path\n  timoni mod init my-app ./modules\n\n  # Create a module from a blueprint\n  timoni mod init my-app --blueprint oci://ghcr.io/stefanprodan/timoni/blueprints/starter\n</code></pre>"},{"location":"cmd/timoni_mod_init/#options","title":"Options","text":"<pre><code>  -b, --blueprint string   Blueprint OCI URL\n  -h, --help               help for init\n</code></pre>"},{"location":"cmd/timoni_mod_init/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_mod_init/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni mod    - Commands for managing modules</li> </ul>"},{"location":"cmd/timoni_mod_list/","title":"Timoni mod list","text":""},{"location":"cmd/timoni_mod_list/#timoni-mod-list","title":"timoni mod list","text":"<p>List the versions of a module</p>"},{"location":"cmd/timoni_mod_list/#synopsis","title":"Synopsis","text":"<p>The list command prints a table with the module versions and their digests.</p> <pre><code>timoni mod list [MODULE URL] [flags]\n</code></pre>"},{"location":"cmd/timoni_mod_list/#examples","title":"Examples","text":"<pre><code>  # Print the versions and digests of a module\n  timoni mod list oci://docker.io/org/app \n\n  # Print the versions without digests\n  timoni mod list oci://docker.io/org/app --with-digest=false\n\n  # Print the versions of a module from GitHub Container Registry\n  timoni mod list oci://ghcr.io/org/manifests/app \\\n    --creds timoni:$GITHUB_TOKEN\n</code></pre>"},{"location":"cmd/timoni_mod_list/#options","title":"Options","text":"<pre><code>      --creds creds   The credentials for the container registry in the format '&lt;username&gt;[:&lt;password&gt;]'.\n  -h, --help          help for list\n      --with-digest   Resolve the digest of each version. (default true)\n</code></pre>"},{"location":"cmd/timoni_mod_list/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_mod_list/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni mod    - Commands for managing modules</li> </ul>"},{"location":"cmd/timoni_mod_pull/","title":"Timoni mod pull","text":""},{"location":"cmd/timoni_mod_pull/#timoni-mod-pull","title":"timoni mod pull","text":"<p>Pull a module version from a container registry</p>"},{"location":"cmd/timoni_mod_pull/#synopsis","title":"Synopsis","text":"<p>The pull command downloads the module from a container registry and extract its contents the specified directory.</p> <pre><code>timoni mod pull [MODULE URL] [flags]\n</code></pre>"},{"location":"cmd/timoni_mod_pull/#examples","title":"Examples","text":"<pre><code>  # Pull the latest stable version of a module\n  echo $DOCKER_TOKEN | timoni registry login docker.io -u timoni --password-stdin\n  timoni mod pull oci://docker.io/org/app-module \\\n    --output ./path/to/module\n\n  # Pull a specific module version from GitHub Container Registry\n  timoni mod pull oci://ghcr.io/org/modules/app --version 1.0.0 \\\n    --output=./modules/app \\\n    --creds timoni:$GITHUB_TOKEN\n\n  # Verify the Cosign signature and pull (the cosign binary must be present in PATH)\n  timoni mod pull oci://docker.io/org/app-module \\\n    --output=./modules/app \\\n    --verify=cosign \\\n    --cosign-key=/path/to/cosign.pub\n\n  # Verify the Cosign keyless signature and pull (the cosign binary must be present in PATH)\n  timoni artifact pull oci://ghcr.io/org/modules/app \\\n    --output=./modules/app \\\n    --verify=cosign \\\n    --certificate-identity-regexp=\"^https://github.com/org/.*$\" \\\n    --certificate-oidc-issuer=https://token.actions.githubusercontent.com \\\n</code></pre>"},{"location":"cmd/timoni_mod_pull/#options","title":"Options","text":"<pre><code>      --certificate-identity string             The identity expected in a valid Fulcio certificate for verifying the Cosign signature.\n                                                Valid values include email address, DNS names, IP addresses, and URIs.\n                                                Either --certificate-identity or --certificate-identity-regexp must be set for keyless flows.\n      --certificate-identity-regexp string      A regular expression alternative to --certificate-identity for verifying the Cosign signature.\n                                                Accepts the Go regular expression syntax described at https://golang.org/s/re2syntax.\n                                                Either --certificate-identity or --certificate-identity-regexp must be set for keyless flows.\n      --certificate-oidc-issuer string          The OIDC issuer expected in a valid Fulcio certificate for verifying the Cosign signature,\n                                                e.g. https://token.actions.githubusercontent.com or https://oauth2.sigstore.dev/auth.\n                                                Either --certificate-oidc-issuer or --certificate-oidc-issuer-regexp must be set for keyless flows.\n      --certificate-oidc-issuer-regexp string   A regular expression alternative to --certificate-oidc-issuer for verifying the Cosign signature.\n                                                Accepts the Go regular expression syntax described at https://golang.org/s/re2syntax.\n                                                Either --certificate-oidc-issuer or --certificate-oidc-issuer-regexp must be set for keyless flows.\n      --cosign-key string                       The Cosign public key for verifying the module.\n      --creds creds                             The credentials for the container registry in the format '&lt;username&gt;[:&lt;password&gt;]'.\n  -h, --help                                    help for pull\n  -o, --output string                           The directory path where the module content should be extracted.\n      --verify string                           Verifies the signed module with the specified provvider.\n  -v, --version version                         The version of the module e.g. '1.0.0' or '1.0.0-rc.1'.\n</code></pre>"},{"location":"cmd/timoni_mod_pull/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_mod_pull/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni mod    - Commands for managing modules</li> </ul>"},{"location":"cmd/timoni_mod_push/","title":"Timoni mod push","text":""},{"location":"cmd/timoni_mod_push/#timoni-mod-push","title":"timoni mod push","text":"<p>Push a module to a container registry</p>"},{"location":"cmd/timoni_mod_push/#synopsis","title":"Synopsis","text":"<p>The push command packages the module as an OCI artifact and pushes it to the container registry using the version as the image tag.</p> <pre><code>timoni mod push [MODULE PATH] [MODULE URL] [flags]\n</code></pre>"},{"location":"cmd/timoni_mod_push/#examples","title":"Examples","text":"<pre><code>  # Push a module to Docker Hub using the credentials from '~/.docker/config.json'\n  echo $DOCKER_PAT | docker login --username timoni --password-stdin\n  timoni mod push ./path/to/module oci://docker.io/org/app-module -v 1.0.0\n\n  # Push a module to GitHub Container Registry using a GitHub token\n  timoni mod push ./path/to/module oci://ghcr.io/org/modules/app \\\n    --version=1.0.0 \\\n    --creds timoni:$GITHUB_TOKEN\n\n  # Push a release candidate without marking it as the latest stable\n  timoni mod push ./path/to/module oci://docker.io/org/app-module \\\n    --version=2.0.0-rc.1 \\\n    --latest=false\n\n  # Push a module with custom OCI annotations\n  timoni mod push ./path/to/module oci://ghcr.io/org/modules/app \\\n    --version=1.0.0 \\\n    --annotation='org.opencontainers.image.licenses=Apache-2.0' \\\n    --annotation='org.opencontainers.image.documentation=https://app.org/docs' \\\n    --annotation='org.opencontainers.image.description=A timoni.sh module for my app.'\n\n  # Push and sign with Cosign (the cosign binary must be present in PATH)\n  echo $GITHUB_TOKEN | timoni registry login ghcr.io -u timoni --password-stdin\n  export COSIGN_PASSWORD=password\n  timoni mod push ./path/to/module oci://ghcr.io/org/modules/app \\\n    --version=1.0.0 \\\n    --sign=cosign \\\n    --cosign-key=/path/to/cosign.key\n\n  # Push a module and sign it with Cosign Keyless (the cosign binary must be present in PATH)\n  echo $GITHUB_TOKEN | timoni registry login ghcr.io -u timoni --password-stdin\n  timoni mod push ./path/to/module oci://ghcr.io/org/modules/app \\\n    --version=1.0.0 \\\n    --sign=cosign\n</code></pre>"},{"location":"cmd/timoni_mod_push/#options","title":"Options","text":"<pre><code>  -a, --annotation stringArray   Set custom OCI annotations in the format '&lt;key&gt;=&lt;value&gt;'.\n      --cosign-key string        The Cosign private key for signing the module.\n      --creds creds              The credentials for the container registry in the format '&lt;username&gt;[:&lt;password&gt;]'.\n  -h, --help                     help for push\n      --latest                   Tags the current version as the latest stable release. (default true)\n  -o, --output string            The format in which the artifact digest should be printed, can be 'yaml' or 'json'.\n      --sign string              Signs the module with the specified provider.\n  -v, --version version          The version of the module e.g. '1.0.0' or '1.0.0-rc.1'.\n</code></pre>"},{"location":"cmd/timoni_mod_push/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_mod_push/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni mod    - Commands for managing modules</li> </ul>"},{"location":"cmd/timoni_mod_show/","title":"Timoni mod show","text":""},{"location":"cmd/timoni_mod_show/#timoni-mod-show","title":"timoni mod show","text":"<p>Commands for showing module information</p>"},{"location":"cmd/timoni_mod_show/#options","title":"Options","text":"<pre><code>  -h, --help   help for show\n</code></pre>"},{"location":"cmd/timoni_mod_show/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_mod_show/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni mod    - Commands for managing modules</li> <li>timoni mod show config    - Output the #Config structure of a local module</li> </ul>"},{"location":"cmd/timoni_mod_show_config/","title":"Timoni mod show config","text":""},{"location":"cmd/timoni_mod_show_config/#timoni-mod-show-config","title":"timoni mod show config","text":"<p>Output the #Config structure of a local module</p>"},{"location":"cmd/timoni_mod_show_config/#synopsis","title":"Synopsis","text":"<p>The config command parses the local module configuration structure and outputs the information to stdout.</p> <pre><code>timoni mod show config [MODULE PATH] [flags]\n</code></pre>"},{"location":"cmd/timoni_mod_show_config/#examples","title":"Examples","text":"<pre><code>  # print the config of a module in the current directory\n  timoni mod show config\n\n  # output the config to a file, if the file is markdown, the table will overwrite a table in a Configuration section or\n  # be appended to the end of the file\n  timoni mod show config --output ./README.md\n</code></pre>"},{"location":"cmd/timoni_mod_show_config/#options","title":"Options","text":"<pre><code>  -h, --help            help for config\n  -o, --output string   The file to output the config Markdown to, defaults to stdout\n</code></pre>"},{"location":"cmd/timoni_mod_show_config/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_mod_show_config/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni mod show  - Commands for showing module information</li> </ul>"},{"location":"cmd/timoni_mod_vendor/","title":"Timoni mod vendor","text":""},{"location":"cmd/timoni_mod_vendor/#timoni-mod-vendor","title":"timoni mod vendor","text":"<p>Commands for vendoring CUE schemas</p>"},{"location":"cmd/timoni_mod_vendor/#options","title":"Options","text":"<pre><code>  -h, --help   help for vendor\n</code></pre>"},{"location":"cmd/timoni_mod_vendor/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_mod_vendor/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni mod    - Commands for managing modules</li> <li>timoni mod vendor crd  - Vendor Kubernetes CRD CUE schemas</li> <li>timoni mod vendor k8s  - Vendor Kubernetes API CUE schemas</li> </ul>"},{"location":"cmd/timoni_mod_vendor_crd/","title":"Timoni mod vendor crd","text":""},{"location":"cmd/timoni_mod_vendor_crd/#timoni-mod-vendor-crd","title":"timoni mod vendor crd","text":"<p>Vendor Kubernetes CRD CUE schemas</p> <pre><code>timoni mod vendor crd [MODULE PATH] [flags]\n</code></pre>"},{"location":"cmd/timoni_mod_vendor_crd/#examples","title":"Examples","text":"<pre><code>  # Vendor CUE schemas generated from Kubernetes CRDs included in a local YAML file\n  timoni mod vendor crd -f crds.yaml\n\n  # Vendor CUE schemas generated from Kubernetes CRDs included in a remote YAML file\n  timoni mod vendor crd -f https://github.com/fluxcd/flux2/releases/latest/download/install.yaml\n</code></pre>"},{"location":"cmd/timoni_mod_vendor_crd/#options","title":"Options","text":"<pre><code>  -f, --file string   The path to Kubernetes CRD YAML.\n  -h, --help          help for crd\n</code></pre>"},{"location":"cmd/timoni_mod_vendor_crd/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_mod_vendor_crd/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni mod vendor  - Commands for vendoring CUE schemas</li> </ul>"},{"location":"cmd/timoni_mod_vendor_k8s/","title":"Timoni mod vendor k8s","text":""},{"location":"cmd/timoni_mod_vendor_k8s/#timoni-mod-vendor-k8s","title":"timoni mod vendor k8s","text":"<p>Vendor Kubernetes API CUE schemas</p> <pre><code>timoni mod vendor k8s [MODULE PATH] [flags]\n</code></pre>"},{"location":"cmd/timoni_mod_vendor_k8s/#examples","title":"Examples","text":"<pre><code>  # Vendor CUE schemas generated from the latest Kubernetes GA APIs\n  timoni mod vendor k8s\n\n  # Vendor CUE schemas generated from a specific version of Kubernetes GA APIs\n  timoni mod vendor k8s -v 1.28\n</code></pre>"},{"location":"cmd/timoni_mod_vendor_k8s/#options","title":"Options","text":"<pre><code>  -h, --help             help for k8s\n  -v, --version string   The Kubernetes minor version e.g. 1.28. (default \"latest\")\n</code></pre>"},{"location":"cmd/timoni_mod_vendor_k8s/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_mod_vendor_k8s/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni mod vendor  - Commands for vendoring CUE schemas</li> </ul>"},{"location":"cmd/timoni_mod_vet/","title":"Timoni mod vet","text":""},{"location":"cmd/timoni_mod_vet/#timoni-mod-vet","title":"timoni mod vet","text":"<p>Validate a local module</p>"},{"location":"cmd/timoni_mod_vet/#synopsis","title":"Synopsis","text":"<p>The vet command builds the local module and validates the resulting Kubernetes objects.</p> <pre><code>timoni mod vet [MODULE PATH] [flags]\n</code></pre>"},{"location":"cmd/timoni_mod_vet/#examples","title":"Examples","text":"<pre><code>  # validate module using default values\n  timoni mod vet\n\n  # validate module using debug values\n  timoni mod vet ./path/to/module --debug\n</code></pre>"},{"location":"cmd/timoni_mod_vet/#options","title":"Options","text":"<pre><code>      --debug             Use debug_values.cue if found in the module root instead of the default values.\n  -h, --help              help for vet\n      --name string       Name of the instance used to build the module (default \"default\")\n  -p, --package package   The name of the module's package used for building the templates. (default main)\n  -f, --values strings    The local path to values files (cue, yaml or json format).\n</code></pre>"},{"location":"cmd/timoni_mod_vet/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_mod_vet/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni mod    - Commands for managing modules</li> </ul>"},{"location":"cmd/timoni_registry/","title":"Timoni registry","text":""},{"location":"cmd/timoni_registry/#timoni-registry","title":"timoni registry","text":"<p>Commands for managing the authentication to container registries</p>"},{"location":"cmd/timoni_registry/#options","title":"Options","text":"<pre><code>  -h, --help   help for registry\n</code></pre>"},{"location":"cmd/timoni_registry/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_registry/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni    - A package manager for Kubernetes powered by CUE.</li> <li>timoni registry login  - Log in to a registry</li> <li>timoni registry logout    - Log out of a registry</li> </ul>"},{"location":"cmd/timoni_registry_login/","title":"Timoni registry login","text":""},{"location":"cmd/timoni_registry_login/#timoni-registry-login","title":"timoni registry login","text":"<p>Log in to a registry</p> <pre><code>timoni registry login [OPTIONS] [SERVER] [flags]\n</code></pre>"},{"location":"cmd/timoni_registry_login/#examples","title":"Examples","text":"<pre><code>  # Log in to reg.example.com\n  timoni registry login reg.example.com -u AzureDiamond -p hunter2\n</code></pre>"},{"location":"cmd/timoni_registry_login/#options","title":"Options","text":"<pre><code>  -h, --help              help for login\n  -p, --password string   Password\n      --password-stdin    Take the password from stdin\n  -u, --username string   Username\n</code></pre>"},{"location":"cmd/timoni_registry_login/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_registry_login/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni registry  - Commands for managing the authentication to container registries</li> </ul>"},{"location":"cmd/timoni_registry_logout/","title":"Timoni registry logout","text":""},{"location":"cmd/timoni_registry_logout/#timoni-registry-logout","title":"timoni registry logout","text":"<p>Log out of a registry</p> <pre><code>timoni registry logout [SERVER] [flags]\n</code></pre>"},{"location":"cmd/timoni_registry_logout/#examples","title":"Examples","text":"<pre><code>  # Log out of reg.example.com\n  timoni registry logout reg.example.com\n</code></pre>"},{"location":"cmd/timoni_registry_logout/#options","title":"Options","text":"<pre><code>  -h, --help   help for logout\n</code></pre>"},{"location":"cmd/timoni_registry_logout/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_registry_logout/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni registry  - Commands for managing the authentication to container registries</li> </ul>"},{"location":"cmd/timoni_runtime/","title":"Timoni runtime","text":""},{"location":"cmd/timoni_runtime/#timoni-runtime","title":"timoni runtime","text":"<p>Commands for managing runtimes</p>"},{"location":"cmd/timoni_runtime/#options","title":"Options","text":"<pre><code>  -h, --help   help for runtime\n</code></pre>"},{"location":"cmd/timoni_runtime/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_runtime/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni    - A package manager for Kubernetes powered by CUE.</li> <li>timoni runtime build    - Build validates the runtime definition, queries the cluster, extracts the values and prints them</li> </ul>"},{"location":"cmd/timoni_runtime_build/","title":"Timoni runtime build","text":""},{"location":"cmd/timoni_runtime_build/#timoni-runtime-build","title":"timoni runtime build","text":"<p>Build validates the runtime definition, queries the cluster, extracts the values and prints them</p> <pre><code>timoni runtime build [flags]\n</code></pre>"},{"location":"cmd/timoni_runtime_build/#examples","title":"Examples","text":"<pre><code>  #  Print the runtime values from a cluster\n  timoni runtime build -f runtime.cue\n</code></pre>"},{"location":"cmd/timoni_runtime_build/#options","title":"Options","text":"<pre><code>      --cluster string         Select cluster by name. (default \"*\")\n      --cluster-group string   Select clusters by group name. (default \"*\")\n  -f, --file strings           The local path to runtime.cue files.\n  -h, --help                   help for build\n</code></pre>"},{"location":"cmd/timoni_runtime_build/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_runtime_build/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni runtime    - Commands for managing runtimes</li> </ul>"},{"location":"cmd/timoni_status/","title":"Timoni status","text":""},{"location":"cmd/timoni_status/#timoni-status","title":"timoni status","text":"<p>Displays the current status of Kubernetes resources managed by an instance</p> <pre><code>timoni status [INSTANCE NAME] [flags]\n</code></pre>"},{"location":"cmd/timoni_status/#examples","title":"Examples","text":"<pre><code>  # Show the current status of the managed resources\n  timoni -n apps status app\n</code></pre>"},{"location":"cmd/timoni_status/#options","title":"Options","text":"<pre><code>  -h, --help   help for status\n</code></pre>"},{"location":"cmd/timoni_status/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_status/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni    - A package manager for Kubernetes powered by CUE.</li> </ul>"},{"location":"cmd/timoni_version/","title":"Timoni version","text":""},{"location":"cmd/timoni_version/#timoni-version","title":"timoni version","text":"<p>Print the client and API version information</p> <pre><code>timoni version [flags]\n</code></pre>"},{"location":"cmd/timoni_version/#examples","title":"Examples","text":"<pre><code>timoni version -o yaml\n</code></pre>"},{"location":"cmd/timoni_version/#options","title":"Options","text":"<pre><code>  -h, --help            help for version\n  -o, --output string   The format in which the version information should be printed, can be 'yaml' or 'json' (default \"yaml\")\n</code></pre>"},{"location":"cmd/timoni_version/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string                    Artifacts cache dir, can be disable with 'TIMONI_CACHING=false' env var. (defaults to \"$HOME/.timoni/cache\")\n      --kube-as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation.\n      --kube-certificate-authority string   Path to a cert file for the certificate authority.\n      --kube-client-certificate string      Path to a client certificate file for TLS.\n      --kube-client-key string              Path to a client key file for TLS.\n      --kube-context string                 The name of the kubeconfig context to use.\n      --kube-insecure-skip-tls-verify       if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kube-server string                  The address and port of the Kubernetes API server.\n      --kube-tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server.\n      --kubeconfig string                   Path to the kubeconfig file.\n      --log-color                           Adds colorized output to the logs. (defaults to false when no tty)\n      --log-pretty                          Adds timestamps to the logs. (default true)\n  -n, --namespace string                    The the namespace scope for the operation. (default \"default\")\n      --registry-insecure                   If true, allows connecting to a container registry without TLS or with a self-signed certificate.\n      --timeout duration                    The length of time to wait before giving up on the current operation. (default 5m0s)\n</code></pre>"},{"location":"cmd/timoni_version/#see-also","title":"SEE ALSO","text":"<ul> <li>timoni    - A package manager for Kubernetes powered by CUE.</li> </ul>"},{"location":"cue/introduction/","title":"CUE Language","text":"<p>CUE is the configuration language used by Timoni. We chose CUE due to its expressive syntax, powerful data validation model, and ability to generate Kubernetes configuration while ensuring the result is consistent and unambiguous.</p> <p>Timoni embeds the CUE engine enabling software vendors to define complex application deployments packaged as CUE modules. Kubernetes' operators can then refer to these modules in their own CUE definitions, allowing them to deploy and manage the lifecycle of applications in a reliable manner.</p>"},{"location":"cue/introduction/#what-is-cue","title":"What is CUE?","text":"<p>CUE stands for Configure, Unify, Execute. The CUE language is a superset of JSON, it reduces the verbosity of JSON and allows C-style comments.</p> <p>While JSON is a data format, CUE is a data constraint language, allowing embedding logic within the data using if statements, for loops, comprehensions, string interpolation, arithmetic operations, regular expressions, and more.</p> <p>CUE can be used for data validation, data templating, configuration, querying, code generation and even scripting.</p>"},{"location":"cue/introduction/#why-cue-for-kubernetes","title":"Why CUE for Kubernetes?","text":"<p>What sets CUE apart from other configuration languages is that CUE merges types, values and constraints into a single concept, think of JSON and JSONSchema all-in-one.</p> <p>What makes CUE the ideal configuration language for Kubernetes is its ability to import the Kubernetes OpenAPI schema (both for the builtin Kinds and CRDs) and use it to validate the generated YAML configuration. When writing templates for Kubernetes with CUE, you can be sure that the generated YAML is valid and will not be rejected by the API server.</p> <p>Timoni vendor commands</p> <p>Timoni streamlines the process of importing Kubernetes schemas with the <code>timoni mod vendor</code> commands:</p> <ul> <li><code>timoni mod vendor k8s</code> imports the schema of Kubernetes builtin Kinds</li> <li><code>timoni mod vendor crd</code> imports the schema of Kubernetes CRDs</li> </ul> <p>CUE makes it easy to define complex Kubernetes objects and build abstractions on top of them. To reduce the boilerplate, CUE allows defining common schemas, constraints and default values that can be reused across multiple Kubernetes objects.</p> <p>Timoni CUE definitions</p> <p>Timoni comes with a set of CUE definitions for the most common Kubernetes constructs, such as Metadata, Label Selectors, Resource Requirements, Container Images, Image Pull Secrets, and more.</p>"},{"location":"cue/introduction/#who-maintains-cue","title":"Who maintains CUE?","text":"<p>The CUE language was originally developed at Google by Marcel van Lohuizen who co-created the Borg Configuration Language (BCL). Although CUE is very different from BCL, it incorporates many of the lessons learned from 15 years of BCL usage.</p> <p>Nowadays, CUE is an independent open source project maintained by a dedicated team, with a growing community of contributors and users.</p> <p>CUE is licensed under the Apache 2.0 license, the source code is hosted on GitHub and accepts contributions from the community, for more information see the contributing guidelines.</p> <p>Everyone is welcome to join the CUE community, for more information please see the community page.</p>"},{"location":"cue/walkthrough/","title":"CUE Features Walkthrough","text":"<p>To work on Timoni modules a basic understanding of CUE is required. This guide will walk you through the core features of CUE and how to use them to generate Kubernetes objects.</p> <p>We'll start with a basic Kubernetes Service definition, and we'll gradually add more features to reduce the boilerplate and improve the validation of the generated YAML.</p>"},{"location":"cue/walkthrough/#command-line-tool","title":"Command Line Tool","text":"<p>Before we begin, make sure you have the CUE CLI installed. To install CUE with Homebrew, run:</p> <pre><code>brew install cue\n</code></pre> <p>For more installation options, follow the instructions from the official documentation.</p> <p>It is recommended to use the same CUE version as the one embedded in Timoni, which can be found by running: <code>timoni version</code>.</p> <p>Timoni CUE dependency</p> <p>Note that Timoni embeds the CUE engine, so you don't need to install it separately in order to use Timoni. The CUE CLI is only required when developing modules to format the CUE files before publishing the modules to container registries.</p> <p>CUE comes with a rich set of CLI commands. Throughout this guide, we'll be using the following commands:</p> <ul> <li><code>cue fmt</code> - format CUE files</li> <li><code>cue eval</code> - evaluate CUE expressions</li> <li><code>cue vet</code> - validate CUE definitions</li> </ul>"},{"location":"cue/walkthrough/#builtin-types","title":"Builtin Types","text":"<p>CUE defines the following type hierarchy:</p> <ul> <li><code>null</code></li> <li><code>bool</code></li> <li><code>string</code></li> <li><code>bytes</code></li> <li><code>number</code> (<code>int</code> and <code>float</code>)</li> <li><code>struct</code></li> <li><code>list</code></li> <li><code>_</code> (any type)</li> <li><code>_|_</code> (error type)</li> </ul>"},{"location":"cue/walkthrough/#structs-and-fields","title":"Structs and Fields","text":"<p>Struct is the most important composite type in CUE, its members are called fields. A field is a key-value pair, where the key is a string and the value is any CUE type.</p> <p>We'll use a Kubernetes Service as an example to demonstrate how to define a struct in CUE.</p> service.cueservice.yaml <pre><code>package main\n\nnginxSvc: {\n    apiVersion: \"v1\"\n    kind:       \"Service\"\n    metadata: {\n        name:      \"nginx\"\n        namespace: \"default\"\n    }\n    spec: {\n        selector: \"app.kubernetes.io/name\": \"nginx\"\n        ports: [{\n            name:       \"http\"\n            port:       80\n            targetPort: 80\n        }]\n    }\n}\n</code></pre> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  namespace: default\nspec:\n  selector:\n    app.kubernetes.io/name: nginx\n  ports:\n    - name: http\n      port: 80\n      targetPort: 80\n</code></pre> <p>To generate the Kubernetes Service YAML, save the CUE definition in a file called <code>service.cue</code>, and used the <code>cue eval</code> command to evaluate the <code>nginxSvc</code> struct and output it in YAML format:</p> <pre><code>cue eval -e nginxSvc --out yaml\n</code></pre>"},{"location":"cue/walkthrough/#field-immutability","title":"Field Immutability","text":"<p>In CUE structs are merged, which means you can define a struct with the same name in multiple places in the same package, as long as the fields are not duplicated.</p> <p>For example, you can add a label to the <code>selector</code> in a new code block:</p> service.cueservice.yaml <pre><code>package main\n\nnginxSvc: {\n    apiVersion: \"v1\"\n    kind:       \"Service\"\n    metadata: {\n        name:      \"nginx\"\n        namespace: \"default\"\n    }\n    spec: {\n        selector: \"app.kubernetes.io/name\": \"nginx\"\n        ports: [{\n            name:       \"http\"\n            port:       80\n            targetPort: 80\n        }]\n    }\n}\n\nnginxSvc: spec: selector: \"app.kubernetes.io/component\": \"proxy\"\n</code></pre> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  namespace: default\nspec:\n  selector:\n    app.kubernetes.io/name: nginx\n    app.kubernetes.io/component: proxy\n  ports:\n    - name: http\n      port: 80\n      targetPort: 80\n</code></pre> <p>In CUE fields are immutable, which means that once a field is set to a concrete value, its value cannot be changed.</p> <p>To demonstrate immutability, let's try to rename our service by adding a new code block to the <code>service.cue</code> file:</p> <pre><code>nginxSvc: metadata: name: \"nginx-2\"\n</code></pre> <p>If you run the eval command, you'll notice that the <code>name</code> field reports an error:</p> <pre><code>$ cue eval -e nginxSvc --out yaml\nnginxSvc.metadata.name: conflicting values \"nginx-2\" and \"nginx\":\n    ./service.cue:5:14\n    ./service.cue:18:27\n</code></pre>"},{"location":"cue/walkthrough/#schema-definitions","title":"Schema Definitions","text":"<p>CUE definitions, indicated by an identifier starting with <code>#</code>, are used to define schema against which concrete values such as structs can be validated.</p> <p>The following example demonstrates how to define a basic <code>#Service</code> schema and how to assign it to the <code>nginxSvc</code> struct:</p> schema.cueservice.cueservice.yaml <pre><code>package main\n\n#Service: {\n    apiVersion: string\n    kind:       string\n    metadata: {\n        name:      string\n        namespace: string\n    }\n    spec: {\n        selector: [string]: string\n        ports: [{\n            name:       string\n            port:       int\n            targetPort: int | string\n        }]\n    }\n}\n</code></pre> <pre><code>package main\n\n// Set the schema\nnginxSvc: #Service\n\n// Set the concrete values\nnginxSvc: {\n    apiVersion: \"v1\"\n    kind:       \"Service\"\n    metadata: {\n        name:      \"nginx\"\n        namespace: \"default\"\n    }\n    spec: {\n        selector: \"app.kubernetes.io/name\": \"nginx\"\n        ports: [{\n            name:       \"http\"\n            port:       80\n            targetPort: 80\n        }]\n    }\n}\n</code></pre> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  namespace: default\nspec:\n  selector:\n    app.kubernetes.io/name: nginx\n  ports:\n    - name: http\n      port: 80\n      targetPort: 80\n</code></pre> <p>Save the schema in a file called <code>schema.cue</code>. To make our service use the <code>#Service</code> schema, in <code>service.cue</code> we'll have to change its definition to <code>nginxSvc: #Service</code>.</p> <p>To validate the <code>nginxSvc</code> struct against the <code>#Service</code> schema, run:</p> <pre><code>cue vet --concrete\n</code></pre> <p>While the current schema is very basic, it has reduced by a lot the mistakes that can be made when defining a Kubernetes Service.</p> <ul> <li>We can no longer define a Service without specifying all the fields present in the schema.</li> <li>We can't set a field value to a different type than the one defined in the schema.</li> <li>We can't add fields that are not present in the schema, a typo in a field name will not go unnoticed.</li> </ul> <p>To demonstrate the schema validation, let's try to change the <code>port</code> field in <code>service.cue</code> to a string e.g. <code>port: \"80\"</code>.</p> <p>If you run the vet or eval command, you'll notice that the <code>port</code> field reports an error:</p> <pre><code>$ cue eval -e nginxSvc --out yaml\nnginxSvc.spec.ports.0.port: conflicting values int and \"80\" (mismatched types int and string):\n    ./schema.cue:14:16\n    ./service.cue:17:16\n</code></pre> <p>CUE allows setting multiple types for a field, in the example above, the <code>targetPort</code> field can be either an <code>int</code> or a <code>string</code>. To demonstrate this, let's change the <code>targetPort</code> field in <code>service.cue</code> to a string, e.g. <code>targetPort: \"http\"</code>.</p> <p>If you run the eval command, you'll notice that the <code>targetPort</code> field passes validation and the output YAML contains the string value.</p>"},{"location":"cue/walkthrough/#default-values","title":"Default values","text":"<p>In CUE, you can set default values for fields using the <code>*</code> operator, e.g. <code>apiVersion: string | *\"v1\"</code>.</p> <p>To reduce the boilerplate, we can define default values for fields such as <code>apiVersion</code>, <code>kind</code>  and <code>namespace</code>.</p> schema.cueservice.cueservice.yaml <pre><code>package main\n\n#Service: {\n    apiVersion: string | *\"v1\"\n    kind:       string | *\"Service\"\n    metadata: {\n        name:      string\n        namespace: string | *\"default\"\n    }\n    spec: {\n        selector: [string]: string\n        ports: [{\n            name:       string\n            port:       int\n            targetPort: int | string\n        }]\n    }\n}\n</code></pre> <pre><code>package main\n\n// Set the schema\nnginxSvc: #Service\n\nnginxSvc: {\n    metadata: name: \"nginx\"\n    spec: {\n        selector: \"app.kubernetes.io/name\": \"nginx\"\n        ports: [{\n            name:       \"http\"\n            port:       80\n            targetPort: \"http\"\n        }]\n    }\n}\n</code></pre> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  namespace: default\nspec:\n  selector:\n    app.kubernetes.io/name: nginx\n  ports:\n    - name: http\n      port: 80\n      targetPort: http\n</code></pre> <p>The fields with default values set in schema can be omitted from the struct definition.</p> <p>If you run the eval command to generate the YAML, you'll notice that the fields with defaults are present in output.</p>"},{"location":"cue/walkthrough/#required-fields","title":"Required Fields","text":"<p>To improve the validation of the <code>#Service</code> schema, we can mark fields such as <code>name</code> and <code>port</code> as required using the <code>!</code> operator e.g. <code>name!: string</code>.</p> schema.cueservice.cueservice.yaml <pre><code>package main\n\n#Service: {\n    apiVersion: string | *\"v1\"\n    kind:       string | *\"Service\"\n    metadata: {\n        name!:     string\n        namespace: string | *\"default\"\n    }\n    spec!: {\n        selector: [string]: string\n        ports: [{\n            name:      string\n            port!:      int\n            targetPort: int | string\n        }]\n    }\n}\n</code></pre> <pre><code>package main\n\n// Set the schema\nnginxSvc: #Service\n\nnginxSvc: {\n    metadata: {\n        name: \"nginx\"\n    }\n    spec: {\n        selector: \"app.kubernetes.io/name\": \"nginx\"\n        ports: [{\n            name:       \"http\"\n            port:       80\n            targetPort: \"http\"\n        }]\n    }\n}\n</code></pre> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  namespace: default\nspec:\n  selector:\n    app.kubernetes.io/name: nginx\n  ports:\n    - name: http\n      port: 80\n      targetPort: http\n</code></pre> <p>To demonstrate the required fields validation, let's try to remove the <code>port</code> field from <code>service.cue</code>.</p> <p>If you run the vet or eval command, you'll notice that the <code>port</code> field reports an error:</p> <pre><code>$ cue eval -e nginxSvc --out yaml\nnginxSvc.spec.ports.0.port: field is required but not present:\n    ./schema.cue:14:4\n    ./service.cue:4:11\n</code></pre>"},{"location":"cue/walkthrough/#optional-fields","title":"Optional Fields","text":"<p>To make the <code>#Service</code> schema match the Kubernetes specification, we can mark fields such as <code>selector</code> and <code>ports</code> as optional, using the <code>?</code> operator e.g. <code>selector?: [string]: string</code>.</p> <p>We'll also add <code>labels</code> and <code>annotations</code> as optional fields to the <code>metadata</code> struct. And finally, we'll extend the Service spec with <code>type</code>, <code>clusterIP</code>, <code>externalName</code> and <code>protocol</code> as optional fields to complete the schema.</p> schema.cueservice.cueservice.yaml <pre><code>package main\n\n#Service: {\n    apiVersion: string | *\"v1\"\n    kind:       string | *\"Service\"\n    metadata: {\n        name!:     string\n        namespace: string | *\"default\"\n        labels?: [string]:      string\n        annotations?: [string]: string\n    }\n    spec!: {\n        type?:         string\n        clusterIP?:    string\n        externalName?: string\n        selector?: [string]: string\n        ports?: [...{\n            name?:       string\n            protocol:    *\"TCP\" | \"UDP\" | \"SCTP\"\n            port!:       int &amp; &gt;=1 &amp; &lt;=65535\n            targetPort?: int | string\n        }]\n    }\n}\n</code></pre> <pre><code>package main\n\n// Set the schema\nnginxSvc: #Service\n\nnginxSvc: {\n    metadata: {\n        name:      \"nginx\"\n        namespace: \"default\"\n    }\n    spec: {\n        type: \"ClusterIP\"\n        selector: \"app.kubernetes.io/name\": \"nginx\"\n        ports: [{\n            name: \"http\"\n            port: 80\n        }]\n    }\n}\n</code></pre> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  namespace: default\nspec:\n  selector:\n    app.kubernetes.io/name: nginx\n  ports:\n    - name: http\n      protocol: TCP\n      port: 80\n</code></pre> <p>To demonstrate the optional fields validation, let's try to remove the <code>targetPort</code> field from <code>service.cue</code>.</p> <p>If you run the eval command to generate the YAML, you'll notice that the <code>targetPort</code> field is not present in the output.</p>"},{"location":"cue/walkthrough/#field-constraints","title":"Field Constraints","text":"<p>To improve the validation of the <code>#Service</code> schema, we can add constraints to its fields.</p> <p>For example, we can constrain the <code>name</code> field to match the Kubernetes naming convention, using a regular expression e.g. <code>name!: =~\"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$\"</code>.</p> <p>We can also constrain the <code>port</code> field to be in the range 1-65535, using the <code>&gt;=</code> and <code>&lt;=</code> operators e.g. <code>port!: &gt;=1 &amp; &lt;=65535</code>.</p> <p>We can also constrain the <code>type</code> field to match one of the allowed values, using the <code>|</code> operator e.g. <code>type: *\"ClusterIP\" | \"NodePort\" | \"LoadBalancer\" | \"ExternalName\"</code>.</p> schema.cueservice.cueservice.yaml <pre><code>package main\n\n#Service: {\n    apiVersion: string | *\"v1\"\n    kind:       string | *\"Service\"\n    metadata: {\n        name!:     string &amp; =~\"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$\"\n        namespace: string | *\"default\"\n        labels?: [string]:      string\n        annotations?: [string]: string\n    }\n    spec!: {\n        type:          *\"ClusterIP\" | \"NodePort\" | \"LoadBalancer\" | \"ExternalName\"\n        clusterIP?:    string\n        externalName?: string\n        selector?: [string]: string\n        ports?: [...{\n            name?:       string\n            protocol:    *\"TCP\" | \"UDP\" | \"SCTP\"\n            port!:       int &amp; &gt;=1 &amp; &lt;=65535\n            targetPort?: int | string\n        }]\n    }\n}\n</code></pre> <pre><code>package main\n\n// Set the schema\nnginxSvc: #Service\n\nnginxSvc: {\n    metadata: name: \"nginx\"\n    spec: {\n        selector: \"app.kubernetes.io/name\": \"nginx\"\n        ports: [{\n            name:       \"http\"\n            port:       80\n            targetPort: \"http\"\n        }]\n    }\n}\n</code></pre> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  namespace: default\nspec:\n  selector:\n    app.kubernetes.io/name: nginx\n  ports:\n    - name: http\n      protocol: TCP\n      port: 80\n      targetPort: http\n</code></pre> <p>To demonstrate the field constraints validation, let's try to change the <code>port</code> field in <code>service.cue</code> to a value outside the range 1-65535, e.g. <code>port: 65536</code> and let's add a disallowed character to the <code>name</code> field, e.g. <code>name: \"nginx_proxy\"</code>.</p> <p>If you run the vet or eval command, you'll notice both the <code>name</code> and <code>port</code> fields report an error:</p> <pre><code>$ cue eval -e nginxSvc --out yaml\nnginxSvc.metadata.name: invalid value \"nginx_proxy\" (out of bound =~\"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$\"):\n    ./schema.cue:7:14\n    ./service.cue:5:9\nnginxSvc.spec.ports.0.port: invalid value 65536 (out of bound &lt;=65535):\n    ./schema.cue:20:29\n    ./service.cue:16:10\n</code></pre>"},{"location":"cue/walkthrough/#conditional-fields","title":"Conditional Fields","text":"<p>In CUE, you can use if statements to add fields to a schema definition conditionally.</p> <p>For example, we can add the <code>externalName</code> field to the <code>#Service</code> schema only when the <code>type</code> is set to <code>ExternalName</code>.</p> schema.cueservice.cueservice.yaml <pre><code>package main\n\n#Service: {\n    apiVersion: string | *\"v1\"\n    kind:       string | *\"Service\"\n    metadata: {\n        name!:     string &amp; =~\"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$\"\n        namespace: string | *\"default\"\n    }\n    spec!: {\n        type: *\"ClusterIP\" | \"NodePort\" | \"LoadBalancer\" | \"ExternalName\"\n        if type == \"ExternalName\" {\n            externalName!: string\n        }\n        clusterIP?:   string\n        selector?: [string]: string\n        ports?: [...{\n            name?:       string\n            protocol:    *\"TCP\" | \"UDP\" | \"SCTP\"\n            port!:       int &amp; &gt;=1 &amp; &lt;=65535\n            targetPort?: int | string\n        }]\n    }\n}\n</code></pre> <pre><code>package main\n\n// Set the schema\nnginxSvc: #Service\n\nnginxSvc: {\n    metadata: name: \"nginx\"\n    spec: {\n        selector: \"app.kubernetes.io/name\": \"nginx\"\n        ports: [{\n            name:       \"http\"\n            port:       80\n            targetPort: \"http\"\n        }]\n    }\n}\n</code></pre> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  namespace: default\nspec:\n  type: ClusterIP\n  selector:\n    app.kubernetes.io/name: nginx\n  ports:\n    - name: http\n      protocol: TCP\n      port: 80\n      targetPort: http\n</code></pre> <p>To demonstrate the condition field constraint, let's add <code>externalName: \"example.com\"</code> in <code>service.cue</code> without setting the <code>type</code> to <code>ExternalName</code>.</p> <p>If you run the vet or eval command, you'll notice that the <code>externalName</code> field reports an error:</p> <pre><code>$ cue eval -e nginxSvc --out yaml\nnginxSvc.spec.externalName: field not allowed:\n    ./schema.cue:10:9\n    ./service.cue:10:3\n</code></pre>"},{"location":"cue/walkthrough/#field-references","title":"Field References","text":"<p>In CUE, you can reference field values using dot notation paths. For example, to reference the <code>name</code> field from the <code>metadata</code> struct, you can use the path <code>metadata.name</code> anywhere in <code>spec</code>.</p> service.cueservice.yaml <pre><code>package main\n\nnginxSvc: #Service &amp; {\n    metadata: {\n        name: \"nginx\"\n        // Reference the metadata name field\n        namespace: name\n    }\n    spec: {\n        // Reference the metadata name field\n        selector: \"app.kubernetes.io/name\": metadata.name\n        ports: [{\n            name: \"http\"\n            port: 80\n            // Reference the port name field\n            targetPort: name\n        }]\n    }\n}\n</code></pre> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  namespace: nginx\nspec:\n  type: ClusterIP\n  selector:\n    app.kubernetes.io/name: nginx\n  ports:\n    - name: http\n      protocol: TCP\n      port: 80\n      targetPort: http\n</code></pre> <p>Note that CUE references a value from the nearest enclosing scope, demonstrated above by referencing the <code>name</code> field in both <code>metadata</code> and <code>ports</code>. Inside the <code>metadata</code> struct, the <code>name</code> field references the <code>metadata.name</code> value, while inside the <code>ports</code> list, the <code>name</code> field references the <code>ports[0].name</code> value.</p>"},{"location":"cue/walkthrough/#aliases","title":"Aliases","text":"<p>In CUE, an alias defines a local value that is not a member of a struct and is omitted from the output. Aliases are useful when you want to perform intermediate calculations and reuse the result in multiple places within the same struct.</p> <p>For example, we can define an alias for the app name, and use it to set the <code>name</code> and <code>namespace</code> fields in <code>metadata</code>, and the <code>app.kubernetes.io/name</code> label in <code>selector</code>.</p> service.cueservice.yaml <pre><code>package main\n\nnginxSvc: #Service &amp; {\n    let appName = \"nginx\"\n    metadata: {\n        name:      appName\n        namespace: appName\n    }\n    spec: {\n        selector: \"app.kubernetes.io/name\": appName\n        ports: [{\n            name: \"http\"\n            port: 80\n        }]\n    }\n}\n</code></pre> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  namespace: nginx\nspec:\n  type: ClusterIP\n  selector:\n    app.kubernetes.io/name: nginx\n  ports:\n    - name: http\n      protocol: TCP\n      port: 80\n</code></pre>"},{"location":"cue/walkthrough/#interpolation","title":"Interpolation","text":"<p>Cue supports interpolation in strings, bytes and field names with <code>\\(expr)</code>. The expression can be any CUE expression, including references to other fields.</p> <p>For example, we can declare an alias named <code>kubeLabel</code> and use it to interpolate the domain name in the <code>selector</code> labels. We can also use interpolation to add the <code>metadata.name</code> as a prefix to the port <code>name</code>.</p> service.cueservice.yaml <pre><code>package main\n\nnginxSvc: #Service &amp; {\n    let kubeLabel = \"app.kubernetes.io\"\n    metadata: {\n        name:      \"nginx\"\n        namespace: name\n    }\n    spec: {\n        selector: {\n            \"\\(kubeLabel)/name\":      metadata.name\n            \"\\(kubeLabel)/component\": \"proxy\"\n        }\n        ports: [{\n            name: \"http-\\(metadata.name)\"\n            port: 80\n        }]\n    }\n}\n</code></pre> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  namespace: nginx\nspec:\n  type: ClusterIP\n  selector:\n    app.kubernetes.io/name: nginx\n    app.kubernetes.io/component: proxy\n  ports:\n    - name: http-nginx\n      protocol: TCP\n      port: 80\n</code></pre> <p>Setting prefixes and suffixes to field values can also be accomplished using the <code>+</code> operator, e.g.:</p> <ul> <li><code>name: (metadata.name) + \"-http\"</code></li> <li><code>name: \"http-\" + (metadata.name)</code></li> </ul>"},{"location":"cue/walkthrough/#list-comprehensions","title":"List Comprehensions","text":"<p>Similar to Python and other languages, CUE supports list comprehensions using the <code>[for key, value in list { result }]</code> syntax.</p> <p>For example, we can generate a list of Service ports from a list of port numbers.</p> service.cueservice.yaml <pre><code>package main\n\nnginxSvc: #Service &amp; {\n    let appPorts = [80, 443]\n    metadata: name: \"nginx\"\n    spec: {\n        selector: \"app.kubernetes.io/name\": \"nginx\"\n        ports: [for i, p in appPorts {\n            name: \"http-\\(i)\"\n            port: p\n        }]\n    }\n}\n</code></pre> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  namespace: default\nspec:\n  type: ClusterIP\n  selector:\n    app.kubernetes.io/name: nginx\n  ports:\n    - name: http-0\n      protocol: TCP\n      port: 80\n    - name: http-1\n      protocol: TCP\n      port: 443\n</code></pre> <p>Comprehensions can also be used with conditionals, for example to generate the list of ports, but only for port numbers in the range 80-443: <code>[for i, p in appPorts if p &gt;= 80 &amp; p &lt;= 443 { result }]</code>.</p>"},{"location":"cue/walkthrough/#embedding","title":"Embedding","text":"<p>Similar to OOP composition, CUE allows the embedding of a definition into another. Embedding is useful when you want to create specialised schemas which further constrain the fields of the base schema.</p> <p>For example, we can embed the <code>#Service</code> schema into a <code>#HeadlessService</code> schema, and set concrete values to the <code>type</code> and <code>clusterIP</code> fields.</p> schema.cueservice.cueservice.yaml <pre><code>package main\n\n#HeadlessService: #Service &amp; {\n    spec!: {\n        type:      \"ClusterIP\"\n        clusterIP: \"None\"\n    }\n}\n\n#Service: {\n    apiVersion: string | *\"v1\"\n    kind:       string | *\"Service\"\n    metadata: {\n        name!:     string &amp; =~\"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$\"\n        namespace: string | *\"default\"\n        labels?: [string]:      string\n        annotations?: [string]: string\n    }\n    spec!: {\n        type:         *\"ClusterIP\" | \"NodePort\" | \"LoadBalancer\" | \"ExternalName\"\n        appProtocol?: string\n        clusterIP?:   string\n        if type == \"ExternalName\" {\n            externalName!: string\n        }\n        selector?: [string]: string\n        ports?: [...{\n            name?:       string\n            protocol:    *\"TCP\" | \"UDP\" | \"SCTP\"\n            port!:       int &amp; &gt;=1 &amp; &lt;=65535\n            targetPort?: int | string\n        }]\n    }\n}\n</code></pre> <pre><code>package main\n\nnginxSvc: #HeadlessService &amp; {\n    metadata: name: \"nginx\"\n    spec: {\n        selector: \"app.kubernetes.io/name\": \"nginx\"\n        ports: [{\n            name:       \"http\"\n            port:       80\n        }]\n    }\n}\n</code></pre> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  namespace: default\nspec:\n  type: ClusterIP\n  clusterIP: None\n  selector:\n    app.kubernetes.io/name: nginx\n  ports:\n    - name: http\n      protocol: TCP\n      port: 80\n</code></pre> <p>To make our service use the <code>#HeadlessService</code> schema, we'll have to change its definition to <code>nginxSvc: #HeadlessService</code>.</p> <p>While we can configure the metadata and ports, we can no longer set the <code>type</code> and <code>clusterIP</code> fields, as they are set by the <code>#HeadlessService</code> schema.</p>"},{"location":"cue/module/apply-behavior/","title":"Control the Apply Behavior","text":"<p>Timoni allows changing the default apply behaviour of Kubernetes resources with the <code>action.timoni.sh</code> annotations.</p>"},{"location":"cue/module/apply-behavior/#annotations","title":"Annotations","text":"CUE Generated YAML <code>timoniv1.Action.Force</code> <code>action.timoni.sh/force: enabled</code> <code>timoniv1.Action.OneOff</code> <code>action.timoni.sh/one-off: enabled</code> <code>timoniv1.Action.Keep</code> <code>action.timoni.sh/prune: disabled</code> <code>timoniv1.Action.DisableWaiting</code> <code>action.timoni.sh/wait: disabled</code>"},{"location":"cue/module/apply-behavior/#force-apply","title":"Force Apply","text":"<p>To recreate immutable resources such as Kubernetes Jobs, these resources can be annotated with <code>action.timoni.sh/force: \"enabled\"</code>.</p> <p>Example:</p> <pre><code>package templates\n\nimport (\n    batchv1 \"k8s.io/api/batch/v1\"\n    timoniv1 \"timoni.sh/core/v1alpha1\"\n)\n\n#TestJob: batchv1.#Job &amp; {\n    #config:    #Config\n    apiVersion: \"batch/v1\"\n    kind:       \"Job\"\n    metadata: timoniv1.#MetaComponent &amp; {\n        #Meta:      #config.metadata\n        #Component: \"test\"\n    }\n    metadata: annotations: timoniv1.Action.Force\n    spec: {...}\n}\n</code></pre>"},{"location":"cue/module/apply-behavior/#one-off-apply","title":"One-Off Apply","text":"<p>To apply resources only if they don't exist on the cluster, these resources can be annotated with <code>action.timoni.sh/one-off: \"enabled\"</code>.</p> <p>Example:</p> <pre><code>package templates\n\nimport (\n    batchv1 \"k8s.io/api/batch/v1\"\n    timoniv1 \"timoni.sh/core/v1alpha1\"\n)\n\n#InstallJob: batchv1.#Job &amp; {\n    #config:    #Config\n    apiVersion: \"batch/v1\"\n    kind:       \"Job\"\n    metadata: timoniv1.#MetaComponent &amp; {\n        #Meta:      #config.metadata\n        #Component: \"install\"\n    }\n    metadata: annotations: timoniv1.Action.OneOff\n    spec: {...}\n}\n</code></pre>"},{"location":"cue/module/apply-behavior/#disable-pruning","title":"Disable Pruning","text":"<p>To prevent Timoni's garbage collector from deleting certain resources such as Kubernetes Persistent Volume Claims, these resources can be annotated with <code>action.timoni.sh/prune: \"disabled\"</code>.</p> <p>Example:</p> <pre><code>package templates\n\nimport (\n    corev1 \"k8s.io/api/core/v1\"\n    timoniv1 \"timoni.sh/core/v1alpha1\"\n)\n\n#DatabasePVC: corev1.#PersistentVolumeClaim &amp; {\n    #config:    #Config\n    apiVersion: \"v1\"\n    kind:       \"PersistentVolumeClaim\"\n    metadata: timoniv1.#MetaComponent &amp; {\n        #Meta:      #config.metadata\n        #Component: \"database\"\n    }\n    metadata: annotations: timoniv1.Action.Keep\n    spec: {...}\n}\n</code></pre>"},{"location":"cue/module/apply-behavior/#disable-waiting","title":"Disable Waiting","text":"<p>To prevent Timoni's readiness check from waiting for certain resources such as Kubernetes Persistent Volumes, these resources can be annotated with <code>action.timoni.sh/wait: \"disabled\"</code>.</p> <p>Example:</p> <pre><code>package templates\n\nimport (\n    corev1 \"k8s.io/api/core/v1\"\n    timoniv1 \"timoni.sh/core/v1alpha1\"\n)\n\n#DatabasePV: corev1.#PersistentVolume &amp; {\n    #config:    #Config\n    apiVersion: \"v1\"\n    kind:       \"PersistentVolume\"\n    metadata: timoniv1.#MetaComponent &amp; {\n        #Meta:      #config.metadata\n        #Component: \"database\"\n    }\n    metadata: annotations: timoniv1.Action.DisableWaiting\n    spec: {...}\n}\n</code></pre>"},{"location":"cue/module/custom-resources/","title":"Kubernetes Custom Resources","text":"<p>Timoni allows defining Kubernetes Custom Resources (CRs) in modules and can ensure that these are validated against their Kubernetes Custom Resource Definitions (CRDs).</p> <p>To enable validation for custom resources, you have to generate the CUE schemas from the Kubernetes CRDs OpenAPI validation spec with the <code>timoni mod vendor crds</code> command.</p>"},{"location":"cue/module/custom-resources/#example","title":"Example","text":"<p>To demonstrate this feature, we'll use the Prometheus Operator CRDs, and we'll add a <code>ServiceMonitor</code> custom resource to a Timoni module.</p>"},{"location":"cue/module/custom-resources/#vendor-prometheus-operator-crds","title":"Vendor Prometheus Operator CRDs","text":"<p>From the root dir of your module, run the <code>timoni mod vendor crds</code> command, and pass the URL to the YAML file which contains the Prometheus Operator CRDs:</p> <pre><code>timoni mod vendor crds -f https://github.com/prometheus-operator/prometheus-operator/releases/download/v0.68.0/stripped-down-crds.yaml\n</code></pre> <p>The above command will generate the CUE schemas corresponding to the Kubernetes CRDs inside the <code>cue.mod/gen</code> directory:</p> <pre><code>cue.mod/gen/\n\u2514\u2500\u2500 monitoring.coreos.com\n    \u251c\u2500\u2500 alertmanager\n    \u251c\u2500\u2500 alertmanagerconfig\n    \u251c\u2500\u2500 podmonitor\n    \u251c\u2500\u2500 probe\n    \u251c\u2500\u2500 prometheus\n    \u251c\u2500\u2500 prometheusagent\n    \u251c\u2500\u2500 prometheusrule\n    \u251c\u2500\u2500 scrapeconfig\n    \u251c\u2500\u2500 servicemonitor\n    \u2514\u2500\u2500 thanosruler\n</code></pre>"},{"location":"cue/module/custom-resources/#create-the-servicemonitor-template","title":"Create the <code>ServiceMonitor</code> template","text":"<p>In the <code>templates</code> directory, create a <code>servicemonitor.cue</code> file with the following content:</p> <pre><code>package templates\n\nimport (\n    promv1 \"monitoring.coreos.com/servicemonitor/v1\"\n)\n\n#ServiceMonitor: promv1.#ServiceMonitor &amp; {\n    #config:  #Config\n    metadata: #config.metadata\n    spec: {\n        endpoints: [{\n            // Change this to match the Service port where\n            // your app exposes the /metrics endpoint\n            port:     \"http-metrics\"\n            path:     \"/metrics\"\n            interval: \"\\(#config.monitoring.interval)s\"\n        }]\n        namespaceSelector: matchNames: [#config.metadata.namespace]\n        selector: matchLabels: #config.selector.labels\n    }\n}\n</code></pre> <p>Make sure to replace the <code>port</code> and <code>path</code> values with the ones used by your app. The port name must match one of the ports exposed in the Kubernetes Service template.</p> <p>API Version and Kind</p> <p>Note that for Kubernetes custom resources, you don't need to specify the  <code>apiVersion</code> and <code>kind</code>, these fields are set by Timoni in the generated schema.</p>"},{"location":"cue/module/custom-resources/#add-the-monitoring-configuration","title":"Add the <code>monitoring</code> configuration","text":"<p>In the <code>templates/config.cue</code> file, add the <code>monitoring</code> configuration:</p> <pre><code>#Config: {\n\n    // Promethues service monitor (optional)\n    monitoring: {\n        enabled:  *false | bool\n        interval: *15 | int &amp; &gt;=5 &amp; &lt;=3600\n    }\n\n}\n</code></pre>"},{"location":"cue/module/custom-resources/#add-the-servicemonitor-to-the-instance","title":"Add the <code>ServiceMonitor</code> to the instance","text":"<p>In the <code>templates/config.cue</code> file, add the <code>ServiceMonitor</code> resource to the instance objects:</p> <pre><code>#Instance: {\n    config: #Config\n\n    if config.monitoring.enabled {\n        objects: servicemonitor: #ServiceMonitor &amp; {#config: config}\n    }\n\n}\n</code></pre>"},{"location":"cue/module/custom-resources/#document-the-monitoring-configuration","title":"Document the <code>monitoring</code> configuration","text":"<p>Finally, document the <code>monitoring</code> configuration in the <code>README.md</code> file, so that users know how to enable monitoring if they have Prometheus Operator installed.</p>"},{"location":"cue/module/github-actions/","title":"Module Distribution with GitHub Actions","text":"<p>Timoni can be used in GitHub workflows to perform actions such as build, test and push modules to container registries.</p>"},{"location":"cue/module/github-actions/#usage","title":"Usage","text":"<p>To run Timoni commands on GitHub Linux runners, add the following steps to your GitHub workflow:</p> <pre><code>steps:\n  - name: Setup Timoni\n    uses: stefanprodan/timoni/actions/setup@main\n    with:\n      version: latest # latest or exact version e.g. 0.13.0\n  - name: Run Timoni\n    run: timoni version\n</code></pre>"},{"location":"cue/module/github-actions/#examples","title":"Examples","text":""},{"location":"cue/module/github-actions/#push-to-github-container-registry","title":"Push to GitHub Container Registry","text":"<p>Example workflow for linting, testing and pushing a module to GitHub Container Registry:</p> <pre><code>name: Release module\non:\n  push:\n    tags: ['*'] # semver format\n\npermissions:\n  contents: read # needed for checkout\n  packages: write # needed for GHCR access\n\njobs:\n  push:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Setup Timoni\n        uses: stefanprodan/timoni/actions/setup@main\n      - name: Vet module\n        run: |\n          timoni mod vet ./modules/my-module\n      - name: Push module\n        run: |\n          timoni mod push ./my-module \\\n            oci://ghcr.io/${{ github.repository_owner }}/my-module \\\n            --version ${{ github.ref_name }} \\\n            --creds ${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}  \n            --latest \\\n            -a 'org.opencontainers.image.licenses=Apache-2.0' \\\n            -a 'org.opencontainers.image.source=https://github.com/${{ github.repository }}' \\\n            -a 'org.opencontainers.image.description=My Timoni module.' \n</code></pre>"},{"location":"cue/module/github-actions/#push-and-sign-with-cosign-keyless","title":"Push and sign with Cosign Keyless","text":"<p>Example workflow for pushing and signing the module using Cosign and GitHub OIDC:</p> <pre><code>name: Release and sign module\non:\n  push:\n    tag: ['*'] # semver format\n\npermissions:\n  contents: read # needed for checkout\n  packages: write # needed for GHCR access\n  id-token: write # needed for signing\n\njobs:\n  push:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Setup Cosign\n        uses: sigstore/cosign-installer@main\n      - name: Setup Timoni\n        uses: stefanprodan/timoni/actions/setup@main\n      - name: Login to GHCR\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n      - name: Vet module\n        run: |\n          timoni mod vet ./my-module\n      - name: Push and Sign\n        run: |\n          timoni mod push ./my-module \\\n            oci://ghcr.io/${{ github.repository_owner }}/my-module \\\n            --version ${{ github.ref_name }} \\\n            --latest \\\n            -a 'org.opencontainers.image.licenses=Apache-2.0' \\\n            -a 'org.opencontainers.image.source=https://github.com/${{ github.repository }}' \\\n            -a 'org.opencontainers.image.description=My Timoni module.' \\\n            --sign=cosign\n</code></pre>"},{"location":"cue/module/github-actions/#push-to-docker-hub","title":"Push to Docker Hub","text":"<p>Example workflow for using <code>docker login</code> to authenticate to Docker Hub:</p> <pre><code>name: Release module\non:\n  push:\n    tag: ['*'] # semver format\n\npermissions:\n  contents: read # needed for checkout\n\njobs:\n  push:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Setup Timoni\n        uses: stefanprodan/timoni/actions/setup@main\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          registry: docker.io\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n      - name: Vet module\n        run: |\n          timoni mod vet ./my-module\n      - name: Push\n        run: |\n          timoni mod push ./my-module \\\n            oci://docker.io/my-org/my-module \\\n            --version ${{ github.ref_name }}\n            --latest \\\n            -a 'org.opencontainers.image.licenses=Apache-2.0' \\\n            -a 'org.opencontainers.image.source=https://github.com/${{ github.repository }}' \\\n            -a 'org.opencontainers.image.description=My Timoni module.' \n      - name: Pull\n        run: |\n          mkdir -p /tmp/my-module\n          timoni mod pull oci://docker.io/my-org/my-module \\\n            --version ${{ github.ref_name }} \\\n            --output /tmp/my-module\n</code></pre> <p>Note that docker/login-action can be used to authenticate to any private registry including ACR, ECR, GCR.</p>"},{"location":"cue/module/immutable-config/","title":"Immutable ConfigMaps and Secrets","text":"<p>Timoni offers a CUE definition <code>#ImmutableConfig</code> for generating immutable Kubernetes ConfigMaps and Secrets.</p> <p>When the ConfigMap or Secret data changes, Timoni will create a new object with a new name suffix, and it will update the references to the new object, triggering a rolling update for the application's Deployments, StatefulSets, DaemonSets, etc. The old ConfigMaps and Secrets will be deleted from the cluster after the rolling update is completed.</p>"},{"location":"cue/module/immutable-config/#example","title":"Example","text":"<p>Assuming you want to populate the app Deployment environment variables from a Kubernetes Secret, with data that end-users can set at installation and upgrade time.</p>"},{"location":"cue/module/immutable-config/#create-the-secret-template","title":"Create the <code>Secret</code> template","text":"<p>In the <code>templates</code> directory, create a <code>secret.cue</code> file with the following content:</p> <pre><code>package templates\n\nimport (\n    timoniv1 \"timoni.sh/core/v1alpha1\"\n)\n\n#Secret: timoniv1.#ImmutableConfig &amp; {\n    #config: #Config\n    #Kind:   timoniv1.#SecretKind\n    #Meta:   #config.metadata\n    #Data: {\n        \"LOGGING_LEVEL_ROOT\": #config.logLevel\n    }\n}\n</code></pre> <p>The <code>#ImmutableConfig</code> definition will generate an immutable <code>Secret</code> resource with the <code>metadata.name</code> set to<code>&lt;instance-name&gt;-&lt;data-hash&gt;</code>, where <code>&lt;data-hash&gt;</code> is a hash of the <code>#Data</code> object. This ensures that the <code>Secret</code> name will change when the <code>#Data</code> content changes.</p> <p>ConfigMap generator</p> <p>If you want to generate a Kubernetes ConfigMap instead of a Secret, set the <code>#Kind</code> to <code>timoniv1.#ConfigMapKind</code>. </p> <p>If you want to generate multiple ConfigMaps and Secrets, to avoid name collisions, set the <code>#Suffix</code> to a unique string, e.g. <code>#Suffix: \"-cm1\"</code>.</p>"},{"location":"cue/module/immutable-config/#reference-the-secret-in-the-deployment-template","title":"Reference the <code>Secret</code> in the <code>Deployment</code> template","text":"<p>In the <code>templates/deployment.cue</code> file, define the <code>secretName</code> as an input parameter, and reference it in <code>envFrom</code>:</p> <pre><code>#Deployment: appsv1.#Deployment &amp; {\n    #config:     #Config\n    #secretName: string \n\n    spec: {\n        template: {\n            spec: {\n                containers: [{\n                    envFrom: [{\n                        secretRef: {\n                            name: #secretName\n                        }\n                    }]\n                }]\n            }\n        }\n    }\n}\n</code></pre> <p>We need to pass the <code>secretName</code> to the <code>Deployment</code> template so that every time the <code>Secret</code> name changes, the <code>Deployment</code> spec will be updated with the new name.</p>"},{"location":"cue/module/immutable-config/#add-the-loglevel-to-the-config-definition","title":"Add the <code>logLevel</code> to the <code>Config</code> definition","text":"<p>In the <code>templates/config.cue</code> file, add the <code>logLevel</code> configuration:</p> <pre><code>#Config: {\n    logLevel: *\"INFO\" | \"DEBUG\" | \"WARN\" | \"ERROR\"\n}\n</code></pre>"},{"location":"cue/module/immutable-config/#add-the-secret-to-the-instance-definition","title":"Add the <code>Secret</code> to the <code>Instance</code> definition","text":"<p>In the <code>templates/config.cue</code> file, add the <code>Secret</code> resource to the instance objects, and pass the generated <code>secret.metadata.name</code> to the <code>Deployment</code> template:</p> <pre><code>#Instance: {\n    config: #Config\n\n    objects: {\n        secret: #Secret &amp; {#config: config}\n\n        deploy: #Deployment &amp; {\n            #config:     config\n            #secretName: secret.metadata.name\n        }\n    }\n}\n</code></pre>"},{"location":"cue/module/import-resources/","title":"Import Kubernetes Resources from YAML","text":"<p>Work in progress</p> <p>This guide is under construction and will be updated soon.</p> <p>The <code>cue</code> CLI can import Kubernetes objects from YAML files and convert them to CUE.</p> <p>Assuming you have a YAML file named <code>manifests.yaml</code> with one or more Kubernetes objects, run the following command in the module's root directory:</p> <pre><code>cue import /path/to/manifests.yaml \\\n  -f -o templates/manifests.cue -p templates \\\n  -l 'strings.ToLower(kind)' -l 'metadata.name'\n</code></pre> <p>The generated CUE definitions will be written to <code>templates/manifests.cue</code>, from where you can modify them to fit with the Timoni's template model.</p>"},{"location":"cue/module/initialization/","title":"Get Started with Timoni Modules","text":"<p>This guide will walk you through the process of creating a new Timoni module. We'll explore the structure of the created module, and the various development commands that Timoni provides to aid module development.</p> <p>Furthermore, this guide provides an overview of the templating system, including the module configuration values, the Kubernetes templates, and how to generate Kubernetes objects from these templates.</p>"},{"location":"cue/module/initialization/#initialize-a-module","title":"Initialize a module","text":"<p>To create a module in the current directory, run the following command:</p> <pre><code>timoni mod init myapp \\\n--blueprint oci://ghcr.io/stefanprodan/timoni/blueprints/starter\n</code></pre> <p>The starter blueprint will create a simple module that deploys a NGINX web server.</p>"},{"location":"cue/module/initialization/#module-structure","title":"Module structure","text":"<p>The init command creates a directory named <code>myapp</code> with the following structure:</p> <pre><code>myapp\n\u251c\u2500\u2500 cue.mod\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 gen # Kubernetes APIs and CRDs schemas\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 pkg # Timoni APIs schemas\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 module.cue # Module metadata\n\u251c\u2500\u2500 templates\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config.cue # Config schema and default values\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 deployment.cue # Kubernetes Deployment template\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 service.cue # Kubernetes Service template\n\u251c\u2500\u2500 timoni.cue # Timoni entry point\n\u251c\u2500\u2500 timoni.ignore # Timoni ignore rules\n\u251c\u2500\u2500 values.cue # Timoni values placeholder \n\u251c\u2500\u2500 LICENSE # Module license\n\u2514\u2500\u2500 README.md # Module documentation\n</code></pre> <p>Navigate to the root directory of the new module with <code>cd myapp</code>, this is where we'll be working from now on.</p>"},{"location":"cue/module/initialization/#development-commands","title":"Development commands","text":"<p>Timoni comes with a set of commands that help with module development.</p> <p>At most times, after making changes, you'll be using the <code>timoni mod vet</code> command to verify that the module config and the Kubernetes templates are valid.</p>"},{"location":"cue/module/initialization/#build-and-apply-the-module","title":"Build and apply the module","text":"<p>To build a module instance, run the following command:</p> <pre><code>timoni -n test build nginx .\n</code></pre> <p>The build command generates a Kubernetes Deployment and Service, and prints the Kubernetes resources to stdout in YAML format.</p> <p>If you inspect the output, you'll notice that the Kubernetes <code>metadata</code> matches the instance name and namespace specified in the build command:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app.kubernetes.io/managed-by: timoni\n    app.kubernetes.io/name: nginx\n    app.kubernetes.io/version: 0.0.0-devel\n  name: nginx\n  namespace: test\n</code></pre> <p>By convention, Timoni uses the <code>app.kubernetes.io/name</code> label to set the Deployment selector and the Service selector.</p> <p>The <code>app.kubernetes.io/version</code> label is used to track the module version from the container registry, and it's set to <code>0.0.0-devel</code> by default, when building a module locally.</p> <p>To create the module instance on a Kubernetes cluster:</p> <pre><code>timoni -n test apply nginx .\n</code></pre> <p>The apply command will create the Kubernetes resources and will wait for the Deployment and Service to become ready. If the <code>test</code> namespace doesn't exist, Timoni will create it.</p> <p>Diff changes</p> <p>When making changes to the module, you can use the <code>timoni apply --diff</code> flag to see the differences between the in-cluster resources and the newly generated ones.</p> <p>To delete the module instance:</p> <pre><code>timoni -n test delete nginx .\n</code></pre> <p>The delete command will remove the Kubernetes Deployment and Service from the cluster, but will leave the <code>test</code> namespace intact, because the namespace resource is not part of the module.</p>"},{"location":"cue/module/initialization/#build-with-custom-values","title":"Build with custom values","text":"<p>For debugging purposes, the blueprint contains a <code>debug_values.cue</code> file that can be used to test the module with custom values.</p> <p>To build a module instance with the debug values, run the following command:</p> <pre><code>timoni -n test build nginx . --values debug_values.cue\n</code></pre> <p>If you inspect the output, you'll notice that the Deployment container image has changed from <code>docker.io/nginx:1-alpine</code> to <code>docker.io/nginx:1-alpine-slim</code>, as specified in the <code>debug_values.cue</code> file.</p> <p>Ignore rules</p> <p>Note that the <code>debug_values.cue</code> file is listed in <code>timoni.ignore</code>, and will be excluded when publishing the module to a container registry. The debug values are meant to be used only for local testing while developing the module.</p>"},{"location":"cue/module/initialization/#vetting-the-module","title":"Vetting the module","text":"<p>The vet command is your best friend when developing modules. It verifies that the module structure is compliant with the Timoni specification, then it builds the module and validates the generated Kubernetes resources against their CUE schemas.</p> <p>To vet the module with default values, run the following command:</p> commandoutput <pre><code>timoni mod vet --name nginx\n</code></pre> <pre><code>INF vetting with default values\nINF Deployment/default/nginx valid resource\nINF Service/default/nginx valid resource\nINF docker.io/nginx:1-alpine valid image (digest missing)\nINF timoni.sh/myapp valid module\n</code></pre> <p>The vet command will print the list of Kubernetes resources and their validation status, along with the container images referenced in the module.</p> <p>It is also possible to verify the module using the debug values:</p> commandoutput <pre><code>timoni mod vet --debug --name nginx --namespace test\n</code></pre> <pre><code>INF vetting with debug values\nINF Deployment/test/nginx valid resource\nINF Service/test/nginx valid resource\nINF docker.io/nginx:1-alpine-slim valid image (digest missing)\nINF timoni.sh/myapp valid module\n</code></pre> <p>If the vet command encounters an invalid definition, it will print the error message, the file and line number where the error occurred.</p>"},{"location":"cue/module/initialization/#format-the-module-files","title":"Format the module files","text":"<p>Similar to Go, CUE has a built-in code formatter that can be used to format CUE files.</p> <p>To format all files in a module, run the following command:</p> <pre><code>cue fmt ./...\n</code></pre> <p>It is recommended to run this command after making changes to a module. Most editors have a CUE plugin that can run the <code>cue fmt</code> command automatically when saving a file.</p>"},{"location":"cue/module/initialization/#update-the-kubernetes-schemas","title":"Update the Kubernetes schemas","text":"<p>To ensure that the Kubernetes resources defined in a module are in conformance with their OpenAPI schema, Timoni offers a command for vendoring CUE definitions generated from the Kubernetes builtin APIs.</p> <p>To update the schemas to the latest Kubernetes stable release, run the following command:</p> <pre><code>timoni mod vendor k8s\n</code></pre> <p>The vendor command will download the Kubernetes schemas from GitHub container registry, and will update the CUE definitions from the <code>cue.mod/gen/k8s.io</code> directory.</p>"},{"location":"cue/module/initialization/#update-the-timoni-schemas","title":"Update the Timoni schemas","text":"<p>Timoni comes with a set of CUE definitions (schemas and generators), that are used to reduce the boilerplate code when developing modules. These definitions are included in the modules generated with <code>timoni mod init</code>, and are vendored in the <code>cue.mod/pkg/timoni</code> directory.</p> <p>To update the Timoni schemas to the latest version, run the following command from within the module root:</p> <pre><code>timoni artifact pull oci://ghcr.io/stefanprodan/timoni/schemas -o cue.mod/pkg\n</code></pre> <p>Schemas versioning</p> <p>The schemas are published with every Timoni release, each Timoni version has a corresponding schemas artifact tag. While the Timoni API is in alpha, the schemas may change between releases in a non-backwards compatible way.</p>"},{"location":"cue/module/initialization/#templates-overview","title":"Templates overview","text":"<p>The templates directory contains the module configuration schema and the Kubernetes resources templates.</p>"},{"location":"cue/module/initialization/#config-definition","title":"Config definition","text":"<p>The <code>config.cue</code> file contains a schema definition called <code>#Config</code> that is used to specify which input fields can be configured by end-users when applying a module instance.</p> <p>For each input field, the <code>#Config</code> definition can specify the field type, if it is required or optional, if it has a default value, and which validation rules should be applied.</p> <p>For example, the <code>#Config</code> contains a <code>replicas</code> field defined like this:</p> <pre><code>#Config: {\n    replicas: *1 | int &amp; &gt;0\n}\n</code></pre> <p>This means that the <code>replicas</code> field defaults to the value of <code>1</code>, and when specified, the user-supplied value must be an integer greater than zero.</p> <p>The <code>replicas</code> value is used in the <code>deployment.cue</code> template to set the <code>spec.replicas</code> field of the Kubernetes Deployment:</p> <pre><code>#Deployment: appsv1.#Deployment &amp; {\n    #config: #Config\n    spec: {\n        replicas: #config.replicas\n    }\n}\n</code></pre>"},{"location":"cue/module/initialization/#instance-definition","title":"Instance definition","text":"<p>The <code>config.cue</code> file contains a definition called <code>#Instance</code> that is used to specify the list of Kubernetes objects that will be generated from templates when building and applying a module instance.</p> <p>For example, the <code>#Instance</code> definition takes as input a <code>#Config</code> object and returns the list of objects with the <code>#Deployment</code> and <code>#Service</code> types:</p> <pre><code>#Instance: {\n    config: #Config\n\n    objects: {\n        deploy: #Deployment &amp; {#config: config}\n        service: #Service &amp; {#config: config}\n    }\n}\n</code></pre> <p>The <code>#Instance</code> definition is used in by the Timoni entry point, defined in <code>timoni.cue</code> file from the root directory, which injects the instance name, namespace and user-supplied config values and then applies the generated objects on the cluster.</p> <pre><code>timoni: {\n    instance: templates.#Instance &amp; {\n        config: values\n        config: metadata: {\n            name:      string @tag(name)\n            namespace: string @tag(namespace)\n        }\n    }\n\n    apply: app: [for obj in instance.objects {obj}]\n}\n</code></pre>"},{"location":"cue/module/initialization/#kubernetes-definitions","title":"Kubernetes definitions","text":"<p>The <code>deployment.cue</code> and <code>service.cue</code> files contain the CUE definitions used to generate the Deployment and Service Kubernetes objects.</p> <p>Let's take a look at the <code>service.cue</code> file:</p> <pre><code>package templates\n\nimport (\n    corev1 \"k8s.io/api/core/v1\"\n)\n\n#Service: corev1.#Service &amp; {\n    #config:    #Config\n    apiVersion: \"v1\"\n    kind:       \"Service\"\n    metadata:   #config.metadata\n    if #config.service.annotations != _|_ {\n        metadata: annotations: #config.service.annotations\n    }\n    spec: corev1.#ServiceSpec &amp; {\n        selector: #config.selector.labels\n        ports: [\n            {\n                port:       #config.service.port\n                protocol:   \"TCP\"\n                name:       \"http\"\n                targetPort: name\n            },\n        ]\n    }\n}\n</code></pre> <p>The <code>package</code> directive specifies the CUE package name, the package name should match the directory name.</p> <p>The <code>import</code> directive is used to import packages from the <code>cue.mod</code> directory, in this case the <code>k8s.io/api/core/v1</code> package is imported as <code>corev1</code>. We need this package to generate any Kubernetes object that is part of the <code>v1</code> API group, like ConfigMap, Secret, ServiceAccount, Service, etc.</p> <p>With <code>#Service: corev1.#Service &amp; {...}</code> we specify that our <code>#Service</code> definition is a Kubernetes Service object, and that it should inherit all the fields from the <code>corev1.#Service</code> type. This ensures that the generated object will be validated against the Kubernetes API schema.</p> <p>Inside the <code>#Service</code> definition, we have a <code>#config</code> field of type <code>#Config</code>. The <code>#config</code> field is used as an input parameter for the user-supplied values.</p> <p>The rest of the <code>#Service</code> definition is used to set the Kubernetes object fields to the <code>#config</code> values.</p> <p>Optional config fields, like the <code>service.annotations</code>, should be set only if the user supplied a value for them. To verify if a field has a value, we can use an if statement and map the config field inside:</p> <pre><code>if #config.service.annotations != _|_ {\n    metadata: annotations: #config.service.annotations\n}\n</code></pre> <p>Besides mapping the config fields to the Kubernetes object fields, we can also set fixed values, like the port <code>protocol</code> and <code>name</code> fields.</p>"},{"location":"cue/module/initialization/#extend-the-module-config","title":"Extend the module config","text":"<p>Assuming that you want to allow users to expose the NGINX service outside the cluster as a NodePort or LoadBalancer type. To do this, you can add a field called <code>type</code> to the <code>service</code> section of the <code>#Config</code> definition, then map the <code>type</code> value to the Kubernetes Service <code>spec.type</code> field.</p>"},{"location":"cue/module/initialization/#add-the-config-field","title":"Add the config field","text":"<p>Open the <code>config.cue</code> file and add the <code>type</code> field to the <code>service</code> section:</p> <pre><code>#Config: {\n    service: {\n        type: *\"ClusterIP\" | \"NodePort\" | \"LoadBalancer\"\n    }\n}\n</code></pre> <p>With the <code>*</code> operator we specify that the <code>type</code> field has a default value of <code>ClusterIP</code>.</p> <p>With the <code>|</code> operator we enumerate the allowed values for the <code>type</code> field.</p> <p>Documentation</p> <p>Note that you should document newly added fields in the module's <code>README.md</code> file. The readme contains a table with the module configuration fields, their type, default value and description.</p>"},{"location":"cue/module/initialization/#map-the-field-in-the-template","title":"Map the field in the template","text":"<p>Open the <code>service.cue</code> file and set the <code>spec.type</code> field to the <code>#config.service.type</code> value:</p> <pre><code>#Service: corev1.#Service &amp; {\n    #config: #Config\n\n    spec: {\n        type: #config.service.type\n    }\n}\n</code></pre>"},{"location":"cue/module/initialization/#test-the-config","title":"Test the config","text":"<p>To test the new config field, we can build the module with the default values, and check the generated Service:</p> <pre><code>timoni build nginx . | grep ClusterIP\n</code></pre> <p>To test if we can change the Service type, we can use the <code>debug_values.cue</code> file:</p> <pre><code>values: {\n    service: type: \"NodePort\"\n}\n</code></pre> <p>And build the module with the debug values:</p> <pre><code>timoni build nginx . -f debug_values.cue | grep NodePort\n</code></pre> <p>Finally, we can test the validation rules by setting an invalid value, e.g. <code>service: type: \"foo\"</code>.</p> <p>Running the build or vet command with the debug values should print a validation error:</p> <pre><code>timoni mod vet --debug\n</code></pre>"},{"location":"cue/module/publishing/","title":"Module Publishing","text":"<p>Timoni modules are distributed as Open Container Initiative (OCI) artifacts. When publishing a module version to a container registry, the version number is used as the OCI artifact tag.</p>"},{"location":"cue/module/publishing/#artifact-format","title":"Artifact format","text":"<p>The OCI artifacts produced with <code>timoni mod push</code> have the following media types:</p> <ul> <li>Image media type <code>application/vnd.oci.image.manifest.v1+json</code></li> <li>Config media type <code>application/vnd.timoni.config.v1+json</code></li> <li>Layer media type <code>application/vnd.timoni.content.v1.tar+gzip</code></li> </ul> <p>The artifacts are annotated with OCI standard annotations:</p> <ul> <li><code>org.opencontainers.image.version: &lt;MODULE VERSION&gt;</code></li> <li><code>org.opencontainers.image.created: &lt;MODULE LAST MODIFIED DATE&gt;</code></li> <li><code>org.opencontainers.image.source: &lt;MODULE GIT URL&gt;</code></li> <li><code>org.opencontainers.image.revision: &lt;MODULE GIT SHA&gt;</code></li> </ul> <p>To enable reproducible builds, Timoni tries to determine the module's last modified date, the source URL and source revision from the Git metadata.</p>"},{"location":"cue/module/publishing/#version-format","title":"Version format","text":"<p>The version format used by Timoni follows the SemVer 2 standard, with the following restrictions:</p> <ul> <li>The version number must take the form <code>X.Y.Z</code> where X, Y, and Z are non-negative integers, and must not contain leading zeroes.</li> <li>Prefixing the version number with <code>v</code> is not supported.</li> <li>Suffixing the version number with build metadata by appending a plus sign is not supported, because the <code>+</code> sign can't be used in OCI tags.</li> </ul> <p>The supported formats are:</p> <ul> <li><code>0.Y.Z</code> - denotes initial development e.g. <code>0.1.2</code></li> <li><code>X.Y.Z</code> - denotes a stable release when  <code>X &gt;= 1</code> e.g. <code>1.0.0</code> or <code>1.23.45</code></li> <li><code>X.Y.Z-alpha.N</code> - denotes an alpha pre-release e.g. <code>2.0.0-alpha.1</code></li> <li><code>X.Y.Z-beta.N</code> - denotes a beta pre-release e.g. <code>2.0.0-beta.1</code></li> <li><code>X.Y.Z-rc.N</code> - denotes a releases candidate e.g. <code>2.0.0-rc.1</code></li> </ul>"},{"location":"cue/module/publishing/#publishing-module-versions","title":"Publishing module versions","text":"<p>Timoni offers a command for publishing a module version by packaging a local module as an OCI artifact and pushing the artifact to a container registry.</p> <p>When publishing a module with timoni mod push, the version number must be specified using the <code>--version</code> flag.</p>"},{"location":"cue/module/publishing/#stable-versions","title":"Stable versions","text":"<p>Example of publishing version <code>1.0.0</code> as the latest stable release:</p> <pre><code>timoni mod push ./modules/my-app oci://ghcr.io/my-org/modules/my-app \\\n  --latest=true \\\n  --version=1.0.0\n</code></pre> <p>To add custom metadata to a version, such as licenses and documentation links please the timoni mod push docs.</p>"},{"location":"cue/module/publishing/#pre-release-versions","title":"Pre-release versions","text":"<p>Example of publishing a pre-release version:</p> <pre><code>timoni mod push ./modules/my-app oci://ghcr.io/my-org/modules/my-app \\\n  --latest=false \\\n  --version=2.0.0-rc.1\n</code></pre>"},{"location":"cue/module/publishing/#latest-version","title":"Latest version","text":"<p>The <code>--latest</code> flag is used to mark a stable release as the latest version. When <code>--latest</code> is set to <code>true</code>, Timoni will push the version tag, then it will tag the version as <code>latest</code> in the container registry.</p> <p>Immutability</p> <p>Note that a Timoni module version should be immutable. The only tag that is suppose to be mutable, is the <code>latest</code> one. Overriding an existing version tag in the container registry should be avoided, some registries allow enforcing immutability for semver tags but this is not guranteed by default.</p> <p>To automate the publishing of module versions, please see the Timoni GitHub Actions doc.</p>"},{"location":"cue/module/publishing/#ignoring-files","title":"Ignoring files","text":"<p>Timoni modules can contain files that are not meant to be published. To exclude files from the module artifact, you can add a <code>timoni.ignore</code> file in the module root directory.</p> <p>The <code>timoni.ignore</code> file must contain rules in the .gitignore pattern format.</p> <p>It is recommended to exclude Git, Go and CUE tools related files, for example:</p> <pre><code># VCS\n.git/\n.gitignore\n.gitmodules\n.gitattributes\n\n# Go\nvendor/\ngo.mod\ngo.sum\n\n# CUE\n*_tool.cue\ndebug_values.cue\n</code></pre>"},{"location":"cue/module/publishing/#listing-module-versions","title":"Listing module versions","text":"<p>Timoni offers a command for listing all the versions available in a container registry for a particular module.</p> <p>The <code>timoni mod list oci://&lt;module-url&gt;</code> prints a table with the versions order by semver and the OCI digest corresponding to each version.</p> <p>Example:</p> <pre><code>$ timoni mod list oci://ghcr.io/stefanprodan/modules/podinfo\nVERSION DIGEST                                                                  \nlatest  sha256:1dba385f9d56f9a79e5b87344bbec1502bd11f056df51834e18d3e054de39365 \n6.5.4   sha256:1dba385f9d56f9a79e5b87344bbec1502bd11f056df51834e18d3e054de39365 \n6.5.3   sha256:54d38b407012ccfb42badf0974ba70f9ae229ecd38f17e8a1f4e7189283b924f \n6.5.2   sha256:6feb340acfc8f566bad9d4fa1e71a3cd0feade41a00750428b4f1b0b5e3c86a0 \n6.5.1   sha256:aa76ad9ab7e7a3efd12af1ceaaaa7e53a165a77869fecc64342c8ea6b1b758e2 \n6.5.0   sha256:d5cb5a8c625045ee1da01d629a2d46cd361f2b6472b8bd07bcabbd0012bc574b \n</code></pre>"},{"location":"cue/module/semver-constraints/","title":"Kubernetes Version Constraints","text":"<p>At apply-time, Timoni reads the Kubernetes version from the live cluster and sets the version string as the value of the <code>kubeVersion</code> field in the module's <code>#Config</code> definition.</p> <p>With the <code>timoniv1.#SemVer</code> helper, you can parse the Kubernetes version string to extract the major and minor version numbers.</p> <pre><code>#Config: {\n    kubeVersion!: string\n    clusterVersion: timoniv1.#SemVer &amp; {\n        #Version: kubeVersion\n        #Minimum: \"0.0.0\"\n    }\n}\n</code></pre>"},{"location":"cue/module/semver-constraints/#enforcing-a-minimum-supported-version","title":"Enforcing a minimum supported version","text":"<p>To enforce a minimum supported version for your module, set a constraint for the minor version e.g. <code>#Minimum: \"1.20.0\"</code>.</p> <p>To test the constraint, you can use the <code>TIMONI_KUBE_VERSION</code> env var with <code>timoni mod vet</code> and <code>timoni build</code>.</p> <pre><code>$ TIMONI_KUBE_VERSION=1.19.0 timoni mod vet\nvalidation failed: clusterVersion.minor: invalid value 19 (out of bound &gt;=20)\n</code></pre>"},{"location":"cue/module/semver-constraints/#conditionally-enabling-features-based-on-cluster-version","title":"Conditionally enabling features based on cluster version","text":"<p>You can use the <code>clusterVersion.minor</code> value to conditionally apply certain Kubernetes resources based on the cluster version.</p> <p>For example, the <code>FlowSchema</code> v1 API was introduced in Kubernetes 1.29. To apply this resource only on clusters running Kubernetes 1.19 or newer, you can use the following condition in your module's <code>#Instance</code> definition:</p> <pre><code>#Instance: {\n    config: #Config\n\n    if config.clusterVersion.minor &gt;= 29 {\n        objects: flowSchema: #FlowSchema &amp; {#config: config}\n    }\n}\n</code></pre>"},{"location":"cue/module/signing/","title":"Module Signing and Verification","text":"<p>Timoni modules are distributed as OCI artifacts. When publishing a module version to a container registry, the OCI artifact can be cryptographically signed to improve the software supply chain security.</p>"},{"location":"cue/module/signing/#cosign","title":"Cosign","text":"<p>Timoni can sign modules using Sigstore Cosign. Cosign is a tool that allows you to sign and verify OCI artifacts with a public/private key pair or with an OIDC token provided by GitHub, Google or Microsoft.</p> <p>To sign modules, you need to install the Cosign v2 binary and place it in the <code>PATH</code> for Timoni to use it.</p>"},{"location":"cue/module/signing/#sign-with-static-keys","title":"Sign with static keys","text":"<p>Generate a cosign key pair:</p> <pre><code>cosign generate-key-pair\n</code></pre> <p>Export the private key password with:</p> <pre><code>export COSIGN_PASSWORD=&lt;your password&gt;\n</code></pre> <p>Sign the module while pushing:</p> <pre><code>timoni mod push ./modules/my-app oci://ghcr.io/my-org/modules/my-app \\\n  --version=1.0.0 \\\n  --sign=cosign \\\n  --cosign-key=cosign.key\n</code></pre> <p>Timoni will push the module to the registry and will pass the OCI artifact digest to Cosign. Cosign will push the signature to the registry and will record the signature in the Rekor transparency log.</p> <p>To verify the module signature:</p> <pre><code>cosign verify ghcr.io/my-org/modules/my-app:1.0.0 --key=cosign.pub\n</code></pre> <p>To verify the module signature while pulling:</p> <pre><code>timoni mod pull oci://ghcr.io/my-org/modules/my-app -v 1.0.0 \\\n  --output ./my-module \\\n  --verify=cosign \\\n  --cosign-key=cosign.pub\n</code></pre>"},{"location":"cue/module/signing/#sign-with-cosign-keyless","title":"Sign with Cosign keyless","text":"<p>For keyless signing, the Cosign CLI would prompt you to confirm that your email will be stored in the public transparency logs. Timoni adds <code>--yes</code> to the cosign command to prevents this prompt.</p> <p>Using Timoni with Cosign keyless signature means that users agree to this statement:</p> <pre><code>Note that there may be personally identifiable information associated with this signed artifact.\nThis may include the email address associated with the account with which you authenticate.\nThis information will be used for signing this artifact and will be stored in public transparency logs and cannot be removed later.\n\nBy typing 'y', you attest that you grant (or have permission to grant) and agree to have this information stored permanently in transparency logs.\n</code></pre> <p>Sign the module while pushing:</p> <pre><code>timoni mod push ./modules/my-app oci://ghcr.io/my-org/modules/my-app \\\n  --version=1.0.0 \\\n  --sign=cosign\n</code></pre> <p>Signing in CI</p> <p>When using <code>timoni push</code> in CI workflows, you can configure GitHub and GitLab to provide Cosign with an OIDC token.  To automate the publishing and signing of module versions, please see the Timoni GitHub Actions.</p> <p>To verify the module signature:</p> <pre><code>cosign verify ghcr.io/my-org/modules/my-app:1.0.0 \\\n  --certificate-identity-regexp=&lt;your email address&gt; \\\n  --certificate-oidc-issuer-regexp=&lt;your issuer URL&gt;\n</code></pre> <p>Verify Signature from GitHub action or GitLab CI/CD</p> <p>When the signature was created in GitHub via the keyless signing you should set the flag <code>--certificate-identity-regexp</code> to a value like <code>^https://github.com/&lt;user|org&gt;/&lt;repo-name&gt;.*</code> and set the flag <code>--certificate-oidc-issuer-regexp</code> to <code>https://token.actions.githubusercontent.com</code>.</p> <p>GitLab is the same setup for the identity flag, <code>https://gitlab.com</code> instead of <code>https://github.com</code> and the oidc issuer is the GitLab instance domain e.g. <code>https://gitlab.com</code></p> <p>Example verification of the podinfo module:</p> <pre><code>cosign verify ghcr.io/stefanprodan/modules/podinfo:latest \\\n  --certificate-identity-regexp=\"^https://github.com/stefanprodan/podinfo.*$\" \\\n  --certificate-oidc-issuer=https://token.actions.githubusercontent.com\n</code></pre> <p>To verify the module signature while pulling:</p> <pre><code>timoni mod pull oci://ghcr.io/my-org/modules/my-app -v 1.0.0 \\\n  --output ./my-module \\\n  --verify=cosign \\\n  --certificate-identity-regexp=&lt;your email address&gt; \\\n  --certificate-oidc-issuer-regexp=&lt;your issuer URL&gt;\n</code></pre>"},{"location":"cue/module/test-jobs/","title":"Run tests with Kubernetes Jobs","text":"<p>Module authors can write end-to-end tests as Kubernetes Jobs that are run by Timoni, after the app workloads are deployed on a cluster.</p> <p>After the app workloads are installed and become ready, Timoni will apply the Kubernetes Jobs and will wait for the created pods to run to completion. On upgrades, Timoni will delete the previous test pods and will recreate the Jobs for the current module values and version.</p> <p>Idempotency</p> <p>Test runs are idempotent, if the module version and values don't change, Timoni will not create new test pods. Tests are run only when a drift is detected in desired state.</p>"},{"location":"cue/module/test-jobs/#example","title":"Example","text":"<p>To demonstrate how tests work, we'll add a Kubernetes Job that verifies that the app is accessible from inside the cluster, by running a curl command against the app's service.</p>"},{"location":"cue/module/test-jobs/#test-definition","title":"Test definition","text":"<p>Add the following CUE definition to the module's <code>templates</code> directory:</p> <pre><code>package templates\n\nimport (\n    \"encoding/yaml\"\n    \"uuid\"\n\n    corev1 \"k8s.io/api/core/v1\"\n    batchv1 \"k8s.io/api/batch/v1\"\n    timoniv1 \"timoni.sh/core/v1alpha1\"\n)\n\n#TestJob: batchv1.#Job &amp; {\n    #config:    #Config\n    apiVersion: \"batch/v1\"\n    kind:       \"Job\"\n    metadata: timoniv1.#MetaComponent &amp; {\n        #Meta:      #config.metadata\n        #Component: \"test\"\n    }\n    metadata: annotations: timoniv1.Action.Force\n    spec: batchv1.#JobSpec &amp; {\n        template: corev1.#PodTemplateSpec &amp; {\n            let checksum = uuid.SHA1(uuid.ns.DNS, yaml.Marshal(#config))\n            metadata: annotations: \"timoni.sh/checksum\": checksum\n            spec: {\n                containers: [{\n                    name:            \"curl\"\n                    image:           #config.test.image.reference\n                    imagePullPolicy: #config.test.image.pullPolicy\n                    command: [\n                        \"curl\",\n                        \"-v\",\n                        \"-m\",\n                        \"5\",\n                        \"\\(#config.metadata.name):\\(#config.service.port)\",\n                    ]\n                }]\n                restartPolicy: \"Never\"\n            }\n        }\n        backoffLimit: 1\n    }\n}\n</code></pre> <p>We set the force annotation on the Job's metadata to instruct Timoni to recreate the Job when it's spec changes. And we compute the checksum of the module's values that we set as an annotation on the Job's pod template. This will trigger a Job recreation when the module version or values change.</p>"},{"location":"cue/module/test-jobs/#test-configuration","title":"Test configuration","text":"<p>To allows users to enable testing, we'll add a <code>test</code> section to the module's <code>#Config</code> definition:</p> <pre><code>#Config: {\n    test: {\n        enabled: *false | bool\n        image: timoniv1.#Image &amp; {\n            repository: *\"docker.io/curlimages/curl\" | string\n            tag:        *\"latest\" | string\n            digest:     *\"\" | string\n        }\n    }\n}\n</code></pre> <p>In the module's <code>#Instance</code> definition we'll add the <code>#TestJob</code> to the <code>tests</code> list:</p> <pre><code>#Instance: {\n    config: #Config\n\n    tests: curl: #TestJob &amp; {#config: config}\n}\n</code></pre> <p>And finally we'll configure Timoni to apply the tests objects in the <code>timoni.cue</code> file with:</p> <pre><code>timoni: {\n\n    apply: app: [for obj in instance.objects {obj}]\n\n    // Conditionally run tests after an install or upgrade.\n    if instance.config.test.enabled {\n        apply: test: [for obj in instance.tests {obj}]\n    }\n}\n</code></pre> <p>Note that the <code>apply: test</code> section goes last, after the <code>apply: app</code> section. Timoni executes the <code>apply</code> sections in order, so the app workloads will be deployed first and then the tests will be applied.</p>"},{"location":"cue/module/test-jobs/#test-execution","title":"Test execution","text":"<p>To verify that the test configuration works, enable testing in the module's <code>debug_values.cue</code> file:</p> <pre><code>values: {\n    test: enabled: true\n}\n</code></pre> <p>Running the vet command with the debug should print the test Job:</p> commandoutput <pre><code>timoni mod vet --debug --name myapp\n</code></pre> <pre><code>INF vetting with debug values\nINF Deployment/default/myapp valid resource\nINF Service/default/myapp valid resource\nINF Job/default/myapp-test valid resource\nINF docker.io/curlimages/curl:latest valid image (digest missing)\nINF docker.io/nginx:1-alpine-slim valid image (digest missing)\nINF timoni.sh/myapp valid module\n</code></pre> <p>Running the apply command with the debug values should create the test Job, after the app workloads are deployed.</p>"}]}